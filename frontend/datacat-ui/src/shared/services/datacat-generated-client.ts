//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { catchError as _observableCatch, mergeMap as _observableMergeMap } from 'rxjs/operators';
import { Observable, of as _observableOf, throwError as _observableThrow } from 'rxjs';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const DATACAT_API_BASE_URL = new InjectionToken<string>('DATACAT_API_BASE_URL');

class ClientBaseService {
  constructor() {
  }
}

@Injectable()
export class ApiService extends ClientBaseService {
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  private http: HttpClient;
  private baseUrl: string;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DATACAT_API_BASE_URL) baseUrl?: string) {
    super();
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  postApiV1SecretAdd(secret: SecretModel): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/secret/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(secret);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1SecretAdd(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1SecretAdd(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  deleteApiV1SecretRemove(key: string): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/secret/remove/{key}";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteApiV1SecretRemove(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteApiV1SecretRemove(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  getApiV1Secret(key: string): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/secret/{key}";
    if (key === undefined || key === null)
      throw new Error("The parameter 'key' must be defined.");
    url_ = url_.replace("{key}", encodeURIComponent("" + key));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1Secret(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1Secret(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  postApiV1PluginAdd(request: AddPluginRequest): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/plugin/add?";
    if (request === undefined || request === null)
      throw new Error("The parameter 'request' must be defined and cannot be null.");
    else
      url_ += "request=" + encodeURIComponent("" + request) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1PluginAdd(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1PluginAdd(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  getApiV1Plugin(id: string): Observable<GetPluginResponse> {
    let url_ = this.baseUrl + "/api/v1/plugin/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1Plugin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1Plugin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetPluginResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetPluginResponse>;
    }));
  }

  deleteApiV1PluginRemove(pluginId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/plugin/remove/{pluginId}";
    if (pluginId === undefined || pluginId === null)
      throw new Error("The parameter 'pluginId' must be defined.");
    url_ = url_.replace("{pluginId}", encodeURIComponent("" + pluginId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({})
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteApiV1PluginRemove(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteApiV1PluginRemove(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  getApiV1PluginSearch(filter?: string | null | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<PageOfSearchPluginsResponse> {
    let url_ = this.baseUrl + "/api/v1/plugin/search?";
    if (filter !== undefined && filter !== null)
      url_ += "filter=" + encodeURIComponent("" + filter) + "&";
    if (page === null)
      throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1PluginSearch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1PluginSearch(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PageOfSearchPluginsResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PageOfSearchPluginsResponse>;
    }));
  }

  postApiV1Plugin(pluginId: string, isActive?: boolean | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/plugin/{pluginId}?";
    if (pluginId === undefined || pluginId === null)
      throw new Error("The parameter 'pluginId' must be defined.");
    url_ = url_.replace("{pluginId}", encodeURIComponent("" + pluginId));
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({})
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1Plugin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1Plugin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  putApiV1PluginUpdate(pluginId: string, request: UpdatePluginRequest): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/plugin/update/{pluginId}";
    if (pluginId === undefined || pluginId === null)
      throw new Error("The parameter 'pluginId' must be defined.");
    url_ = url_.replace("{pluginId}", encodeURIComponent("" + pluginId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPutApiV1PluginUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPutApiV1PluginUpdate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  postApiV1PanelAdd(request: AddPanelRequest): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/panel/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1PanelAdd(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1PanelAdd(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  getApiV1Panel(id: string): Observable<GetPanelResponse> {
    let url_ = this.baseUrl + "/api/v1/panel/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1Panel(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1Panel(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetPanelResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetPanelResponse>;
    }));
  }

  deleteApiV1PanelRemove(panelId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/panel/remove/{panelId}";
    if (panelId === undefined || panelId === null)
      throw new Error("The parameter 'panelId' must be defined.");
    url_ = url_.replace("{panelId}", encodeURIComponent("" + panelId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({})
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteApiV1PanelRemove(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteApiV1PanelRemove(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  putApiV1PanelUpdate(panelId: string, request: UpdatePanelRequest): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/panel/update/{panelId}";
    if (panelId === undefined || panelId === null)
      throw new Error("The parameter 'panelId' must be defined.");
    url_ = url_.replace("{panelId}", encodeURIComponent("" + panelId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPutApiV1PanelUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPutApiV1PanelUpdate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  postApiV1NotificationChannelAdd(request: AddNotificationChannelRequest): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/notification-channel/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1NotificationChannelAdd(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1NotificationChannelAdd(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  getApiV1NotificationChannel(id: string): Observable<GetNotificationChannelResponse> {
    let url_ = this.baseUrl + "/api/v1/notification-channel/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1NotificationChannel(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1NotificationChannel(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetNotificationChannelResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetNotificationChannelResponse>;
    }));
  }

  deleteApiV1NotificationChannelRemove(notificationChannelId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/notification-channel/remove/{notificationChannelId}";
    if (notificationChannelId === undefined || notificationChannelId === null)
      throw new Error("The parameter 'notificationChannelId' must be defined.");
    url_ = url_.replace("{notificationChannelId}", encodeURIComponent("" + notificationChannelId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({})
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteApiV1NotificationChannelRemove(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteApiV1NotificationChannelRemove(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  putApiV1NotificationChannel(notificationChannelId: string, request: UpdateNotificationChannelRequest): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/notification-channel/{notificationChannelId}";
    if (notificationChannelId === undefined || notificationChannelId === null)
      throw new Error("The parameter 'notificationChannelId' must be defined.");
    url_ = url_.replace("{notificationChannelId}", encodeURIComponent("" + notificationChannelId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPutApiV1NotificationChannel(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPutApiV1NotificationChannel(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  getApiV1MetaDatabaseSchema(): Observable<SchemaResponse[]> {
    let url_ = this.baseUrl + "/api/v1/meta/database-schema";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1MetaDatabaseSchema(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1MetaDatabaseSchema(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<SchemaResponse[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<SchemaResponse[]>;
    }));
  }

  getApiV1MetaSqlQueries(): Observable<string[]> {
    let url_ = this.baseUrl + "/api/v1/meta/sql-queries";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1MetaSqlQueries(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1MetaSqlQueries(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string[]>;
    }));
  }

  deleteApiV1DebugRollback(steps: number): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/debug/rollback/{steps}";
    if (steps === undefined || steps === null)
      throw new Error("The parameter 'steps' must be defined.");
    url_ = url_.replace("{steps}", encodeURIComponent("" + steps));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({})
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteApiV1DebugRollback(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteApiV1DebugRollback(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  postApiV1DatasourceAdd(request: AddDataSourceRequest): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/datasource/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1DatasourceAdd(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1DatasourceAdd(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  getApiV1Datasources(id: string): Observable<GetDataSourceResponse> {
    let url_ = this.baseUrl + "/api/v1/datasources/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1Datasources(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1Datasources(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetDataSourceResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetDataSourceResponse>;
    }));
  }

  deleteApiV1DatasourceRemove(dataSourceId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/datasource/remove/{dataSourceId}";
    if (dataSourceId === undefined || dataSourceId === null)
      throw new Error("The parameter 'dataSourceId' must be defined.");
    url_ = url_.replace("{dataSourceId}", encodeURIComponent("" + dataSourceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({})
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteApiV1DatasourceRemove(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteApiV1DatasourceRemove(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  getApiV1DatasourcesSearch(filter?: string | null | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<PageOfSearchDataSourcesResponse> {
    let url_ = this.baseUrl + "/api/v1/datasources/search?";
    if (filter !== undefined && filter !== null)
      url_ += "filter=" + encodeURIComponent("" + filter) + "&";
    if (page === null)
      throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1DatasourcesSearch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1DatasourcesSearch(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PageOfSearchDataSourcesResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PageOfSearchDataSourcesResponse>;
    }));
  }

  putApiV1AlertUpdateConnectionString(dataSourceId: string, request: UpdateDataSourceRequest): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/alert/update-connection-string/{dataSourceId}";
    if (dataSourceId === undefined || dataSourceId === null)
      throw new Error("The parameter 'dataSourceId' must be defined.");
    url_ = url_.replace("{dataSourceId}", encodeURIComponent("" + dataSourceId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPutApiV1AlertUpdateConnectionString(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPutApiV1AlertUpdateConnectionString(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  postApiV1DashboardAdd(request: AddDashboardRequest): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/dashboard/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1DashboardAdd(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1DashboardAdd(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  postApiV1DashboardAddUser(request: AddUserToDashboardRequest): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/dashboard/add-user";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1DashboardAddUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1DashboardAddUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  getApiV1Dashboard(id: string): Observable<GetDashboardResponse> {
    let url_ = this.baseUrl + "/api/v1/dashboard/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1Dashboard(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1Dashboard(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetDashboardResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetDashboardResponse>;
    }));
  }

  getApiV1DashboardFull(id: string): Observable<GetFullInfoDashboardResponse> {
    let url_ = this.baseUrl + "/api/v1/dashboard/{id}/full";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1DashboardFull(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1DashboardFull(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetFullInfoDashboardResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetFullInfoDashboardResponse>;
    }));
  }

  deleteApiV1DashboardRemove(dashboardId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/dashboard/remove/{dashboardId}";
    if (dashboardId === undefined || dashboardId === null)
      throw new Error("The parameter 'dashboardId' must be defined.");
    url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({})
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteApiV1DashboardRemove(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteApiV1DashboardRemove(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  getApiV1DashboardSearch(filter?: string | null | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<PageOfSearchDashboardsResponse> {
    let url_ = this.baseUrl + "/api/v1/dashboard/search?";
    if (filter !== undefined && filter !== null)
      url_ += "filter=" + encodeURIComponent("" + filter) + "&";
    if (page === null)
      throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1DashboardSearch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1DashboardSearch(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PageOfSearchDashboardsResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PageOfSearchDashboardsResponse>;
    }));
  }

  putApiV1DashboardUpdate(dashboardId: string, request: UpdateDashboardRequest): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/dashboard/update/{dashboardId}";
    if (dashboardId === undefined || dashboardId === null)
      throw new Error("The parameter 'dashboardId' must be defined.");
    url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPutApiV1DashboardUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPutApiV1DashboardUpdate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  postApiV1AlertAdd(request: AddAlertRequest): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/alert/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1AlertAdd(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1AlertAdd(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  getApiV1Alert(id: string): Observable<GetAlertResponse> {
    let url_ = this.baseUrl + "/api/v1/alert/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1Alert(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1Alert(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetAlertResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetAlertResponse>;
    }));
  }

  postApiV1AlertMute(alertId: string, nextExecutionTime: string): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/alert/mute/{alertId}?";
    if (alertId === undefined || alertId === null)
      throw new Error("The parameter 'alertId' must be defined.");
    url_ = url_.replace("{alertId}", encodeURIComponent("" + alertId));
    if (nextExecutionTime === undefined || nextExecutionTime === null)
      throw new Error("The parameter 'nextExecutionTime' must be defined and cannot be null.");
    else
      url_ += "nextExecutionTime=" + encodeURIComponent("" + nextExecutionTime) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostApiV1AlertMute(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostApiV1AlertMute(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  deleteApiV1AlertRemove(alertId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/alert/remove/{alertId}";
    if (alertId === undefined || alertId === null)
      throw new Error("The parameter 'alertId' must be defined.");
    url_ = url_.replace("{alertId}", encodeURIComponent("" + alertId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({})
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteApiV1AlertRemove(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteApiV1AlertRemove(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  getApiV1AlertSearch(filter?: string | null | undefined, page?: number | undefined, pageSize?: number | undefined): Observable<PageOfSearchAlertsResponse> {
    let url_ = this.baseUrl + "/api/v1/alert/search?";
    if (filter !== undefined && filter !== null)
      url_ += "filter=" + encodeURIComponent("" + filter) + "&";
    if (page === null)
      throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetApiV1AlertSearch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetApiV1AlertSearch(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PageOfSearchAlertsResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PageOfSearchAlertsResponse>;
    }));
  }

  putApiV1AlertUpdate(alertId: string, request: UpdateAlertRequest): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/alert/update/{alertId}";
    if (alertId === undefined || alertId === null)
      throw new Error("The parameter 'alertId' must be defined.");
    url_ = url_.replace("{alertId}", encodeURIComponent("" + alertId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: true,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPutApiV1AlertUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPutApiV1AlertUpdate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processPostApiV1SecretAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = resultData400 !== undefined ? resultData400 : <any>null;

        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processDeleteApiV1SecretRemove(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = resultData400 !== undefined ? resultData400 : <any>null;

        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1Secret(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPostApiV1PluginAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1Plugin(response: HttpResponseBase): Observable<GetPluginResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetPluginResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processDeleteApiV1PluginRemove(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1PluginSearch(response: HttpResponseBase): Observable<PageOfSearchPluginsResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PageOfSearchPluginsResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPostApiV1Plugin(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPutApiV1PluginUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPostApiV1PanelAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1Panel(response: HttpResponseBase): Observable<GetPanelResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetPanelResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processDeleteApiV1PanelRemove(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPutApiV1PanelUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPostApiV1NotificationChannelAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1NotificationChannel(response: HttpResponseBase): Observable<GetNotificationChannelResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetNotificationChannelResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processDeleteApiV1NotificationChannelRemove(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPutApiV1NotificationChannel(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1MetaDatabaseSchema(response: HttpResponseBase): Observable<SchemaResponse[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(SchemaResponse.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1MetaSqlQueries(response: HttpResponseBase): Observable<string[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(item);
        } else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processDeleteApiV1DebugRollback(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPostApiV1DatasourceAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1Datasources(response: HttpResponseBase): Observable<GetDataSourceResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetDataSourceResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processDeleteApiV1DatasourceRemove(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1DatasourcesSearch(response: HttpResponseBase): Observable<PageOfSearchDataSourcesResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PageOfSearchDataSourcesResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPutApiV1AlertUpdateConnectionString(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPostApiV1DashboardAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPostApiV1DashboardAddUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1Dashboard(response: HttpResponseBase): Observable<GetDashboardResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetDashboardResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1DashboardFull(response: HttpResponseBase): Observable<GetFullInfoDashboardResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetFullInfoDashboardResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processDeleteApiV1DashboardRemove(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1DashboardSearch(response: HttpResponseBase): Observable<PageOfSearchDashboardsResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PageOfSearchDashboardsResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPutApiV1DashboardUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPostApiV1AlertAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1Alert(response: HttpResponseBase): Observable<GetAlertResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetAlertResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPostApiV1AlertMute(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processDeleteApiV1AlertRemove(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processGetApiV1AlertSearch(response: HttpResponseBase): Observable<PageOfSearchAlertsResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PageOfSearchAlertsResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  protected processPutApiV1AlertUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export class SecretModel implements ISecretModel {
  key?: string;
  value?: string;

  constructor(data?: ISecretModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SecretModel {
    data = typeof data === 'object' ? data : {};
    let result = new SecretModel();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data["key"];
      this.value = _data["value"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["key"] = this.key;
    data["value"] = this.value;
    return data;
  }

  clone(): SecretModel {
    const json = this.toJSON();
    let result = new SecretModel();
    result.init(json);
    return result;
  }
}

export interface ISecretModel {
  key?: string;
  value?: string;
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property))
          this[property] = _data[property];
      }
      this.type = _data["type"];
      this.title = _data["title"];
      this.status = _data["status"];
      this.detail = _data["detail"];
      this.instance = _data["instance"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property))
        data[property] = this[property];
    }
    data["type"] = this.type;
    data["title"] = this.title;
    data["status"] = this.status;
    data["detail"] = this.detail;
    data["instance"] = this.instance;
    return data;
  }

  clone(): ProblemDetails {
    const json = this.toJSON();
    let result = new ProblemDetails();
    result.init(json);
    return result;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;
}

export class AddPluginRequest implements IAddPluginRequest {
  file?: string;
  name?: string;
  version?: string;
  author?: string;
  description?: string | undefined;
  settings?: string | undefined;

  constructor(data?: IAddPluginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AddPluginRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AddPluginRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.file = _data["file"];
      this.name = _data["name"];
      this.version = _data["version"];
      this.author = _data["author"];
      this.description = _data["description"];
      this.settings = _data["settings"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["file"] = this.file;
    data["name"] = this.name;
    data["version"] = this.version;
    data["author"] = this.author;
    data["description"] = this.description;
    data["settings"] = this.settings;
    return data;
  }

  clone(): AddPluginRequest {
    const json = this.toJSON();
    let result = new AddPluginRequest();
    result.init(json);
    return result;
  }
}

export interface IAddPluginRequest {
  file?: string;
  name?: string;
  version?: string;
  author?: string;
  description?: string | undefined;
  settings?: string | undefined;
}

export class GetPluginResponse implements IGetPluginResponse {
  pluginId?: string;
  name?: string;
  version?: string | undefined;
  description?: string | undefined;
  author?: string;
  settings?: string | undefined;

  constructor(data?: IGetPluginResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): GetPluginResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetPluginResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.pluginId = _data["pluginId"];
      this.name = _data["name"];
      this.version = _data["version"];
      this.description = _data["description"];
      this.author = _data["author"];
      this.settings = _data["settings"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["pluginId"] = this.pluginId;
    data["name"] = this.name;
    data["version"] = this.version;
    data["description"] = this.description;
    data["author"] = this.author;
    data["settings"] = this.settings;
    return data;
  }

  clone(): GetPluginResponse {
    const json = this.toJSON();
    let result = new GetPluginResponse();
    result.init(json);
    return result;
  }
}

export interface IGetPluginResponse {
  pluginId?: string;
  name?: string;
  version?: string | undefined;
  description?: string | undefined;
  author?: string;
  settings?: string | undefined;
}

export class PageOfSearchPluginsResponse implements IPageOfSearchPluginsResponse {
  items?: SearchPluginsResponse[];
  totalCount?: number;
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPageOfSearchPluginsResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): PageOfSearchPluginsResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PageOfSearchPluginsResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(SearchPluginsResponse.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
      this.totalPages = _data["totalPages"];
      this.hasPreviousPage = _data["hasPreviousPage"];
      this.hasNextPage = _data["hasNextPage"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    data["totalPages"] = this.totalPages;
    data["hasPreviousPage"] = this.hasPreviousPage;
    data["hasNextPage"] = this.hasNextPage;
    return data;
  }

  clone(): PageOfSearchPluginsResponse {
    const json = this.toJSON();
    let result = new PageOfSearchPluginsResponse();
    result.init(json);
    return result;
  }
}

export interface IPageOfSearchPluginsResponse {
  items?: SearchPluginsResponse[];
  totalCount?: number;
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class SearchPluginsResponse implements ISearchPluginsResponse {
  pluginId?: string;
  name?: string;
  version?: string | undefined;
  description?: string | undefined;
  author?: string;
  settings?: string | undefined;

  constructor(data?: ISearchPluginsResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SearchPluginsResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SearchPluginsResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.pluginId = _data["pluginId"];
      this.name = _data["name"];
      this.version = _data["version"];
      this.description = _data["description"];
      this.author = _data["author"];
      this.settings = _data["settings"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["pluginId"] = this.pluginId;
    data["name"] = this.name;
    data["version"] = this.version;
    data["description"] = this.description;
    data["author"] = this.author;
    data["settings"] = this.settings;
    return data;
  }

  clone(): SearchPluginsResponse {
    const json = this.toJSON();
    let result = new SearchPluginsResponse();
    result.init(json);
    return result;
  }
}

export interface ISearchPluginsResponse {
  pluginId?: string;
  name?: string;
  version?: string | undefined;
  description?: string | undefined;
  author?: string;
  settings?: string | undefined;
}

export class UpdatePluginRequest implements IUpdatePluginRequest {
  description?: string;
  settings?: string | undefined;

  constructor(data?: IUpdatePluginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdatePluginRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePluginRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"];
      this.settings = _data["settings"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["description"] = this.description;
    data["settings"] = this.settings;
    return data;
  }

  clone(): UpdatePluginRequest {
    const json = this.toJSON();
    let result = new UpdatePluginRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdatePluginRequest {
  description?: string;
  settings?: string | undefined;
}

export class AddPanelRequest implements IAddPanelRequest {
  title?: string;
  type?: number;
  rawQuery?: string;
  dataSourceId?: string;
  panelX?: number;
  panelY?: number;
  width?: number;
  height?: number;
  dashboardId?: string;

  constructor(data?: IAddPanelRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AddPanelRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AddPanelRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
      this.type = _data["type"];
      this.rawQuery = _data["rawQuery"];
      this.dataSourceId = _data["dataSourceId"];
      this.panelX = _data["panelX"];
      this.panelY = _data["panelY"];
      this.width = _data["width"];
      this.height = _data["height"];
      this.dashboardId = _data["dashboardId"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["title"] = this.title;
    data["type"] = this.type;
    data["rawQuery"] = this.rawQuery;
    data["dataSourceId"] = this.dataSourceId;
    data["panelX"] = this.panelX;
    data["panelY"] = this.panelY;
    data["width"] = this.width;
    data["height"] = this.height;
    data["dashboardId"] = this.dashboardId;
    return data;
  }

  clone(): AddPanelRequest {
    const json = this.toJSON();
    let result = new AddPanelRequest();
    result.init(json);
    return result;
  }
}

export interface IAddPanelRequest {
  title?: string;
  type?: number;
  rawQuery?: string;
  dataSourceId?: string;
  panelX?: number;
  panelY?: number;
  width?: number;
  height?: number;
  dashboardId?: string;
}

export class GetPanelResponse implements IGetPanelResponse {
  id?: string;
  title?: string;
  typeName?: string;
  query?: RawQueryResponse;
  layout?: DataCatLayoutResponse;
  dashboardId?: string;

  constructor(data?: IGetPanelResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): GetPanelResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetPanelResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.title = _data["title"];
      this.typeName = _data["typeName"];
      this.query = _data["query"] ? RawQueryResponse.fromJS(_data["query"]) : <any>undefined;
      this.layout = _data["layout"] ? DataCatLayoutResponse.fromJS(_data["layout"]) : <any>undefined;
      this.dashboardId = _data["dashboardId"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["title"] = this.title;
    data["typeName"] = this.typeName;
    data["query"] = this.query ? this.query.toJSON() : <any>undefined;
    data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
    data["dashboardId"] = this.dashboardId;
    return data;
  }

  clone(): GetPanelResponse {
    const json = this.toJSON();
    let result = new GetPanelResponse();
    result.init(json);
    return result;
  }
}

export interface IGetPanelResponse {
  id?: string;
  title?: string;
  typeName?: string;
  query?: RawQueryResponse;
  layout?: DataCatLayoutResponse;
  dashboardId?: string;
}

export class RawQueryResponse implements IRawQueryResponse {
  query?: string;
  dataSource?: DataSourceResponse;

  constructor(data?: IRawQueryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): RawQueryResponse {
    data = typeof data === 'object' ? data : {};
    let result = new RawQueryResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.query = _data["query"];
      this.dataSource = _data["dataSource"] ? DataSourceResponse.fromJS(_data["dataSource"]) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["query"] = this.query;
    data["dataSource"] = this.dataSource ? this.dataSource.toJSON() : <any>undefined;
    return data;
  }

  clone(): RawQueryResponse {
    const json = this.toJSON();
    let result = new RawQueryResponse();
    result.init(json);
    return result;
  }
}

export interface IRawQueryResponse {
  query?: string;
  dataSource?: DataSourceResponse;
}

export class DataSourceResponse implements IDataSourceResponse {
  id?: string;
  name?: string;
  type?: string;
  connectionString?: string;

  constructor(data?: IDataSourceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): DataSourceResponse {
    data = typeof data === 'object' ? data : {};
    let result = new DataSourceResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.type = _data["type"];
      this.connectionString = _data["connectionString"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["type"] = this.type;
    data["connectionString"] = this.connectionString;
    return data;
  }

  clone(): DataSourceResponse {
    const json = this.toJSON();
    let result = new DataSourceResponse();
    result.init(json);
    return result;
  }
}

export interface IDataSourceResponse {
  id?: string;
  name?: string;
  type?: string;
  connectionString?: string;
}

export class DataCatLayoutResponse implements IDataCatLayoutResponse {
  x?: number;
  y?: number;
  width?: number;
  height?: number;

  constructor(data?: IDataCatLayoutResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): DataCatLayoutResponse {
    data = typeof data === 'object' ? data : {};
    let result = new DataCatLayoutResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.x = _data["x"];
      this.y = _data["y"];
      this.width = _data["width"];
      this.height = _data["height"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["x"] = this.x;
    data["y"] = this.y;
    data["width"] = this.width;
    data["height"] = this.height;
    return data;
  }

  clone(): DataCatLayoutResponse {
    const json = this.toJSON();
    let result = new DataCatLayoutResponse();
    result.init(json);
    return result;
  }
}

export interface IDataCatLayoutResponse {
  x?: number;
  y?: number;
  width?: number;
  height?: number;
}

export class UpdatePanelRequest implements IUpdatePanelRequest {
  title?: string;
  type?: number;
  rawQuery?: string;
  dataSourceId?: string;
  panelX?: number;
  panelY?: number;
  width?: number;
  height?: number;
  dashboardId?: string;

  constructor(data?: IUpdatePanelRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdatePanelRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePanelRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
      this.type = _data["type"];
      this.rawQuery = _data["rawQuery"];
      this.dataSourceId = _data["dataSourceId"];
      this.panelX = _data["panelX"];
      this.panelY = _data["panelY"];
      this.width = _data["width"];
      this.height = _data["height"];
      this.dashboardId = _data["dashboardId"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["title"] = this.title;
    data["type"] = this.type;
    data["rawQuery"] = this.rawQuery;
    data["dataSourceId"] = this.dataSourceId;
    data["panelX"] = this.panelX;
    data["panelY"] = this.panelY;
    data["width"] = this.width;
    data["height"] = this.height;
    data["dashboardId"] = this.dashboardId;
    return data;
  }

  clone(): UpdatePanelRequest {
    const json = this.toJSON();
    let result = new UpdatePanelRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdatePanelRequest {
  title?: string;
  type?: number;
  rawQuery?: string;
  dataSourceId?: string;
  panelX?: number;
  panelY?: number;
  width?: number;
  height?: number;
  dashboardId?: string;
}

export class AddNotificationChannelRequest implements IAddNotificationChannelRequest {
  destinationId?: number;
  settings?: string;

  constructor(data?: IAddNotificationChannelRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AddNotificationChannelRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AddNotificationChannelRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.destinationId = _data["destinationId"];
      this.settings = _data["settings"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["destinationId"] = this.destinationId;
    data["settings"] = this.settings;
    return data;
  }

  clone(): AddNotificationChannelRequest {
    const json = this.toJSON();
    let result = new AddNotificationChannelRequest();
    result.init(json);
    return result;
  }
}

export interface IAddNotificationChannelRequest {
  destinationId?: number;
  settings?: string;
}

export class GetNotificationChannelResponse implements IGetNotificationChannelResponse {
  id?: string;
  destinationName?: string;
  settings?: string;

  constructor(data?: IGetNotificationChannelResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): GetNotificationChannelResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetNotificationChannelResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.destinationName = _data["destinationName"];
      this.settings = _data["settings"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["destinationName"] = this.destinationName;
    data["settings"] = this.settings;
    return data;
  }

  clone(): GetNotificationChannelResponse {
    const json = this.toJSON();
    let result = new GetNotificationChannelResponse();
    result.init(json);
    return result;
  }
}

export interface IGetNotificationChannelResponse {
  id?: string;
  destinationName?: string;
  settings?: string;
}

export class UpdateNotificationChannelRequest implements IUpdateNotificationChannelRequest {
  destinationId?: number;
  settings?: string;

  constructor(data?: IUpdateNotificationChannelRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateNotificationChannelRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateNotificationChannelRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.destinationId = _data["destinationId"];
      this.settings = _data["settings"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["destinationId"] = this.destinationId;
    data["settings"] = this.settings;
    return data;
  }

  clone(): UpdateNotificationChannelRequest {
    const json = this.toJSON();
    let result = new UpdateNotificationChannelRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateNotificationChannelRequest {
  destinationId?: number;
  settings?: string;
}

export class SchemaResponse implements ISchemaResponse {
  migration?: string;
  upSql?: any;
  downSql?: any;

  constructor(data?: ISchemaResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SchemaResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SchemaResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.migration = _data["migration"];
      this.upSql = _data["upSql"];
      this.downSql = _data["downSql"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["migration"] = this.migration;
    data["upSql"] = this.upSql;
    data["downSql"] = this.downSql;
    return data;
  }

  clone(): SchemaResponse {
    const json = this.toJSON();
    let result = new SchemaResponse();
    result.init(json);
    return result;
  }
}

export interface ISchemaResponse {
  migration?: string;
  upSql?: any;
  downSql?: any;
}

export class AddDataSourceRequest implements IAddDataSourceRequest {
  name?: string;
  type?: number;
  connectionString?: string;

  constructor(data?: IAddDataSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AddDataSourceRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AddDataSourceRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.type = _data["type"];
      this.connectionString = _data["connectionString"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["type"] = this.type;
    data["connectionString"] = this.connectionString;
    return data;
  }

  clone(): AddDataSourceRequest {
    const json = this.toJSON();
    let result = new AddDataSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDataSourceRequest {
  name?: string;
  type?: number;
  connectionString?: string;
}

export class GetDataSourceResponse implements IGetDataSourceResponse {
  id?: string;
  name?: string;
  type?: string;
  connectionString?: string;

  constructor(data?: IGetDataSourceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): GetDataSourceResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetDataSourceResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.type = _data["type"];
      this.connectionString = _data["connectionString"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["type"] = this.type;
    data["connectionString"] = this.connectionString;
    return data;
  }

  clone(): GetDataSourceResponse {
    const json = this.toJSON();
    let result = new GetDataSourceResponse();
    result.init(json);
    return result;
  }
}

export interface IGetDataSourceResponse {
  id?: string;
  name?: string;
  type?: string;
  connectionString?: string;
}

export class PageOfSearchDataSourcesResponse implements IPageOfSearchDataSourcesResponse {
  items?: SearchDataSourcesResponse[];
  totalCount?: number;
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPageOfSearchDataSourcesResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): PageOfSearchDataSourcesResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PageOfSearchDataSourcesResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(SearchDataSourcesResponse.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
      this.totalPages = _data["totalPages"];
      this.hasPreviousPage = _data["hasPreviousPage"];
      this.hasNextPage = _data["hasNextPage"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    data["totalPages"] = this.totalPages;
    data["hasPreviousPage"] = this.hasPreviousPage;
    data["hasNextPage"] = this.hasNextPage;
    return data;
  }

  clone(): PageOfSearchDataSourcesResponse {
    const json = this.toJSON();
    let result = new PageOfSearchDataSourcesResponse();
    result.init(json);
    return result;
  }
}

export interface IPageOfSearchDataSourcesResponse {
  items?: SearchDataSourcesResponse[];
  totalCount?: number;
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class SearchDataSourcesResponse implements ISearchDataSourcesResponse {
  id?: string;
  name?: string;
  type?: string;
  connectionString?: string;

  constructor(data?: ISearchDataSourcesResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SearchDataSourcesResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SearchDataSourcesResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.type = _data["type"];
      this.connectionString = _data["connectionString"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["type"] = this.type;
    data["connectionString"] = this.connectionString;
    return data;
  }

  clone(): SearchDataSourcesResponse {
    const json = this.toJSON();
    let result = new SearchDataSourcesResponse();
    result.init(json);
    return result;
  }
}

export interface ISearchDataSourcesResponse {
  id?: string;
  name?: string;
  type?: string;
  connectionString?: string;
}

export class UpdateDataSourceRequest implements IUpdateDataSourceRequest {
  connectionString?: string;

  constructor(data?: IUpdateDataSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateDataSourceRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateDataSourceRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.connectionString = _data["connectionString"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["connectionString"] = this.connectionString;
    return data;
  }

  clone(): UpdateDataSourceRequest {
    const json = this.toJSON();
    let result = new UpdateDataSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDataSourceRequest {
  connectionString?: string;
}

export class AddDashboardRequest implements IAddDashboardRequest {
  name?: string;
  description?: string | undefined;
  userId?: string;

  constructor(data?: IAddDashboardRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AddDashboardRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AddDashboardRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.userId = _data["userId"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["userId"] = this.userId;
    return data;
  }

  clone(): AddDashboardRequest {
    const json = this.toJSON();
    let result = new AddDashboardRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDashboardRequest {
  name?: string;
  description?: string | undefined;
  userId?: string;
}

export class AddUserToDashboardRequest implements IAddUserToDashboardRequest {
  dashboardId?: string;
  userId?: string;

  constructor(data?: IAddUserToDashboardRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AddUserToDashboardRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AddUserToDashboardRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.dashboardId = _data["dashboardId"];
      this.userId = _data["userId"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["dashboardId"] = this.dashboardId;
    data["userId"] = this.userId;
    return data;
  }

  clone(): AddUserToDashboardRequest {
    const json = this.toJSON();
    let result = new AddUserToDashboardRequest();
    result.init(json);
    return result;
  }
}

export interface IAddUserToDashboardRequest {
  dashboardId?: string;
  userId?: string;
}

export class GetDashboardResponse implements IGetDashboardResponse {
  dashboardId?: string;
  name?: string;
  description?: string | undefined;
  ownerId?: string;
  updatedAt?: Date;

  constructor(data?: IGetDashboardResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): GetDashboardResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetDashboardResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.dashboardId = _data["dashboardId"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.ownerId = _data["ownerId"];
      this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["dashboardId"] = this.dashboardId;
    data["name"] = this.name;
    data["description"] = this.description;
    data["ownerId"] = this.ownerId;
    data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    return data;
  }

  clone(): GetDashboardResponse {
    const json = this.toJSON();
    let result = new GetDashboardResponse();
    result.init(json);
    return result;
  }
}

export interface IGetDashboardResponse {
  dashboardId?: string;
  name?: string;
  description?: string | undefined;
  ownerId?: string;
  updatedAt?: Date;
}

export class GetFullInfoDashboardResponse implements IGetFullInfoDashboardResponse {
  dashboardId?: string;
  name?: string;
  description?: string | undefined;
  panels?: SearchDashboardsPanelDetailsResponse[] | undefined;
  ownerId?: string;
  updatedAt?: Date;

  constructor(data?: IGetFullInfoDashboardResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): GetFullInfoDashboardResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetFullInfoDashboardResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.dashboardId = _data["dashboardId"];
      this.name = _data["name"];
      this.description = _data["description"];
      if (Array.isArray(_data["panels"])) {
        this.panels = [] as any;
        for (let item of _data["panels"])
          this.panels!.push(SearchDashboardsPanelDetailsResponse.fromJS(item));
      }
      this.ownerId = _data["ownerId"];
      this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["dashboardId"] = this.dashboardId;
    data["name"] = this.name;
    data["description"] = this.description;
    if (Array.isArray(this.panels)) {
      data["panels"] = [];
      for (let item of this.panels)
        data["panels"].push(item.toJSON());
    }
    data["ownerId"] = this.ownerId;
    data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    return data;
  }

  clone(): GetFullInfoDashboardResponse {
    const json = this.toJSON();
    let result = new GetFullInfoDashboardResponse();
    result.init(json);
    return result;
  }
}

export interface IGetFullInfoDashboardResponse {
  dashboardId?: string;
  name?: string;
  description?: string | undefined;
  panels?: SearchDashboardsPanelDetailsResponse[] | undefined;
  ownerId?: string;
  updatedAt?: Date;
}

export class SearchDashboardsPanelDetailsResponse implements ISearchDashboardsPanelDetailsResponse {
  id?: string;
  title?: string | undefined;
  panelType?: string;
  query?: string;
  layout?: DataCatLayoutResponse;

  constructor(data?: ISearchDashboardsPanelDetailsResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SearchDashboardsPanelDetailsResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SearchDashboardsPanelDetailsResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.title = _data["title"];
      this.panelType = _data["panelType"];
      this.query = _data["query"];
      this.layout = _data["layout"] ? DataCatLayoutResponse.fromJS(_data["layout"]) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["title"] = this.title;
    data["panelType"] = this.panelType;
    data["query"] = this.query;
    data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
    return data;
  }

  clone(): SearchDashboardsPanelDetailsResponse {
    const json = this.toJSON();
    let result = new SearchDashboardsPanelDetailsResponse();
    result.init(json);
    return result;
  }
}

export interface ISearchDashboardsPanelDetailsResponse {
  id?: string;
  title?: string | undefined;
  panelType?: string;
  query?: string;
  layout?: DataCatLayoutResponse;
}

export class PageOfSearchDashboardsResponse implements IPageOfSearchDashboardsResponse {
  items?: SearchDashboardsResponse[];
  totalCount?: number;
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPageOfSearchDashboardsResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): PageOfSearchDashboardsResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PageOfSearchDashboardsResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(SearchDashboardsResponse.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
      this.totalPages = _data["totalPages"];
      this.hasPreviousPage = _data["hasPreviousPage"];
      this.hasNextPage = _data["hasNextPage"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    data["totalPages"] = this.totalPages;
    data["hasPreviousPage"] = this.hasPreviousPage;
    data["hasNextPage"] = this.hasNextPage;
    return data;
  }

  clone(): PageOfSearchDashboardsResponse {
    const json = this.toJSON();
    let result = new PageOfSearchDashboardsResponse();
    result.init(json);
    return result;
  }
}

export interface IPageOfSearchDashboardsResponse {
  items?: SearchDashboardsResponse[];
  totalCount?: number;
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class SearchDashboardsResponse implements ISearchDashboardsResponse {
  dashboardId?: string;
  name?: string;
  description?: string | undefined;
  ownerId?: string;
  updatedAt?: Date;

  constructor(data?: ISearchDashboardsResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SearchDashboardsResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SearchDashboardsResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.dashboardId = _data["dashboardId"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.ownerId = _data["ownerId"];
      this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["dashboardId"] = this.dashboardId;
    data["name"] = this.name;
    data["description"] = this.description;
    data["ownerId"] = this.ownerId;
    data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    return data;
  }

  clone(): SearchDashboardsResponse {
    const json = this.toJSON();
    let result = new SearchDashboardsResponse();
    result.init(json);
    return result;
  }
}

export interface ISearchDashboardsResponse {
  dashboardId?: string;
  name?: string;
  description?: string | undefined;
  ownerId?: string;
  updatedAt?: Date;
}

export class UpdateDashboardRequest implements IUpdateDashboardRequest {
  name?: string;
  description?: string | undefined;

  constructor(data?: IUpdateDashboardRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateDashboardRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateDashboardRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    return data;
  }

  clone(): UpdateDashboardRequest {
    const json = this.toJSON();
    let result = new UpdateDashboardRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDashboardRequest {
  name?: string;
  description?: string | undefined;
}

export class AddAlertRequest implements IAddAlertRequest {
  description?: string | undefined;
  rawQuery?: string;
  dataSourceId?: string;
  notificationChannelId?: string;
  waitTimeBeforeAlerting?: string;
  repeatInterval?: string;

  constructor(data?: IAddAlertRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): AddAlertRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AddAlertRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"];
      this.rawQuery = _data["rawQuery"];
      this.dataSourceId = _data["dataSourceId"];
      this.notificationChannelId = _data["notificationChannelId"];
      this.waitTimeBeforeAlerting = _data["waitTimeBeforeAlerting"];
      this.repeatInterval = _data["repeatInterval"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["description"] = this.description;
    data["rawQuery"] = this.rawQuery;
    data["dataSourceId"] = this.dataSourceId;
    data["notificationChannelId"] = this.notificationChannelId;
    data["waitTimeBeforeAlerting"] = this.waitTimeBeforeAlerting;
    data["repeatInterval"] = this.repeatInterval;
    return data;
  }

  clone(): AddAlertRequest {
    const json = this.toJSON();
    let result = new AddAlertRequest();
    result.init(json);
    return result;
  }
}

export interface IAddAlertRequest {
  description?: string | undefined;
  rawQuery?: string;
  dataSourceId?: string;
  notificationChannelId?: string;
  waitTimeBeforeAlerting?: string;
  repeatInterval?: string;
}

export class GetAlertResponse implements IGetAlertResponse {
  id?: string;
  description?: string | undefined;
  rawQuery?: string;
  status?: string;
  dataSource?: DataSourceResponse;
  notificationChannel?: NotificationChannelResponse;
  previousExecutionTime?: Date;
  nextExecutionTime?: Date;
  waitTimeBeforeAlerting?: string;
  repeatInterval?: string;

  constructor(data?: IGetAlertResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): GetAlertResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetAlertResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.description = _data["description"];
      this.rawQuery = _data["rawQuery"];
      this.status = _data["status"];
      this.dataSource = _data["dataSource"] ? DataSourceResponse.fromJS(_data["dataSource"]) : <any>undefined;
      this.notificationChannel = _data["notificationChannel"] ? NotificationChannelResponse.fromJS(_data["notificationChannel"]) : <any>undefined;
      this.previousExecutionTime = _data["previousExecutionTime"] ? new Date(_data["previousExecutionTime"].toString()) : <any>undefined;
      this.nextExecutionTime = _data["nextExecutionTime"] ? new Date(_data["nextExecutionTime"].toString()) : <any>undefined;
      this.waitTimeBeforeAlerting = _data["waitTimeBeforeAlerting"];
      this.repeatInterval = _data["repeatInterval"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["description"] = this.description;
    data["rawQuery"] = this.rawQuery;
    data["status"] = this.status;
    data["dataSource"] = this.dataSource ? this.dataSource.toJSON() : <any>undefined;
    data["notificationChannel"] = this.notificationChannel ? this.notificationChannel.toJSON() : <any>undefined;
    data["previousExecutionTime"] = this.previousExecutionTime ? this.previousExecutionTime.toISOString() : <any>undefined;
    data["nextExecutionTime"] = this.nextExecutionTime ? this.nextExecutionTime.toISOString() : <any>undefined;
    data["waitTimeBeforeAlerting"] = this.waitTimeBeforeAlerting;
    data["repeatInterval"] = this.repeatInterval;
    return data;
  }

  clone(): GetAlertResponse {
    const json = this.toJSON();
    let result = new GetAlertResponse();
    result.init(json);
    return result;
  }
}

export interface IGetAlertResponse {
  id?: string;
  description?: string | undefined;
  rawQuery?: string;
  status?: string;
  dataSource?: DataSourceResponse;
  notificationChannel?: NotificationChannelResponse;
  previousExecutionTime?: Date;
  nextExecutionTime?: Date;
  waitTimeBeforeAlerting?: string;
  repeatInterval?: string;
}

export class NotificationChannelResponse implements INotificationChannelResponse {
  id?: string;
  destinationName?: string;
  settings?: string;

  constructor(data?: INotificationChannelResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): NotificationChannelResponse {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationChannelResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.destinationName = _data["destinationName"];
      this.settings = _data["settings"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["destinationName"] = this.destinationName;
    data["settings"] = this.settings;
    return data;
  }

  clone(): NotificationChannelResponse {
    const json = this.toJSON();
    let result = new NotificationChannelResponse();
    result.init(json);
    return result;
  }
}

export interface INotificationChannelResponse {
  id?: string;
  destinationName?: string;
  settings?: string;
}

export class PageOfSearchAlertsResponse implements IPageOfSearchAlertsResponse {
  items?: SearchAlertsResponse[];
  totalCount?: number;
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPageOfSearchAlertsResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): PageOfSearchAlertsResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PageOfSearchAlertsResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(SearchAlertsResponse.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
      this.totalPages = _data["totalPages"];
      this.hasPreviousPage = _data["hasPreviousPage"];
      this.hasNextPage = _data["hasNextPage"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    data["totalPages"] = this.totalPages;
    data["hasPreviousPage"] = this.hasPreviousPage;
    data["hasNextPage"] = this.hasNextPage;
    return data;
  }

  clone(): PageOfSearchAlertsResponse {
    const json = this.toJSON();
    let result = new PageOfSearchAlertsResponse();
    result.init(json);
    return result;
  }
}

export interface IPageOfSearchAlertsResponse {
  items?: SearchAlertsResponse[];
  totalCount?: number;
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class SearchAlertsResponse implements ISearchAlertsResponse {
  id?: string;
  description?: string | undefined;
  rawQuery?: string;
  status?: string;
  dataSource?: DataSourceResponse;
  notificationChannel?: NotificationChannelResponse;
  previousExecutionTime?: Date;
  nextExecutionTime?: Date;
  waitTimeBeforeAlerting?: string;
  repeatInterval?: string;

  constructor(data?: ISearchAlertsResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): SearchAlertsResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SearchAlertsResponse();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.description = _data["description"];
      this.rawQuery = _data["rawQuery"];
      this.status = _data["status"];
      this.dataSource = _data["dataSource"] ? DataSourceResponse.fromJS(_data["dataSource"]) : <any>undefined;
      this.notificationChannel = _data["notificationChannel"] ? NotificationChannelResponse.fromJS(_data["notificationChannel"]) : <any>undefined;
      this.previousExecutionTime = _data["previousExecutionTime"] ? new Date(_data["previousExecutionTime"].toString()) : <any>undefined;
      this.nextExecutionTime = _data["nextExecutionTime"] ? new Date(_data["nextExecutionTime"].toString()) : <any>undefined;
      this.waitTimeBeforeAlerting = _data["waitTimeBeforeAlerting"];
      this.repeatInterval = _data["repeatInterval"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["description"] = this.description;
    data["rawQuery"] = this.rawQuery;
    data["status"] = this.status;
    data["dataSource"] = this.dataSource ? this.dataSource.toJSON() : <any>undefined;
    data["notificationChannel"] = this.notificationChannel ? this.notificationChannel.toJSON() : <any>undefined;
    data["previousExecutionTime"] = this.previousExecutionTime ? this.previousExecutionTime.toISOString() : <any>undefined;
    data["nextExecutionTime"] = this.nextExecutionTime ? this.nextExecutionTime.toISOString() : <any>undefined;
    data["waitTimeBeforeAlerting"] = this.waitTimeBeforeAlerting;
    data["repeatInterval"] = this.repeatInterval;
    return data;
  }

  clone(): SearchAlertsResponse {
    const json = this.toJSON();
    let result = new SearchAlertsResponse();
    result.init(json);
    return result;
  }
}

export interface ISearchAlertsResponse {
  id?: string;
  description?: string | undefined;
  rawQuery?: string;
  status?: string;
  dataSource?: DataSourceResponse;
  notificationChannel?: NotificationChannelResponse;
  previousExecutionTime?: Date;
  nextExecutionTime?: Date;
  waitTimeBeforeAlerting?: string;
  repeatInterval?: string;
}

export class UpdateAlertRequest implements IUpdateAlertRequest {
  description?: string | undefined;
  rawQuery?: string;
  dataSourceId?: string;
  notificationChannelId?: string;

  constructor(data?: IUpdateAlertRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  static fromJS(data: any): UpdateAlertRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateAlertRequest();
    result.init(data);
    return result;
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"];
      this.rawQuery = _data["rawQuery"];
      this.dataSourceId = _data["dataSourceId"];
      this.notificationChannelId = _data["notificationChannelId"];
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["description"] = this.description;
    data["rawQuery"] = this.rawQuery;
    data["dataSourceId"] = this.dataSourceId;
    data["notificationChannelId"] = this.notificationChannelId;
    return data;
  }

  clone(): UpdateAlertRequest {
    const json = this.toJSON();
    let result = new UpdateAlertRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateAlertRequest {
  description?: string | undefined;
  rawQuery?: string;
  dataSourceId?: string;
  notificationChannelId?: string;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;
  protected isApiException = true;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: {
  [key: string]: any;
}, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
