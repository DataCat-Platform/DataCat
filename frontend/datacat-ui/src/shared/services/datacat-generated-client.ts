//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const DATACAT_API_BASE_URL = new InjectionToken<string>('DATACAT_API_BASE_URL');

@Injectable()
export class ApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DATACAT_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    postApiV1VariableAdd(request: AddVariableRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/variable/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1VariableAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1VariableAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1VariableAdd(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1Variable(id: string): Observable<VariableResponse> {
        let url_ = this.baseUrl + "/api/v1/variable/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1Variable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1Variable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VariableResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VariableResponse>;
        }));
    }

    protected processGetApiV1Variable(response: HttpResponseBase): Observable<VariableResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VariableResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1VariablesDashboard(dashboardId: string): Observable<VariableResponse[]> {
        let url_ = this.baseUrl + "/api/v1/variables/dashboard/{dashboardId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1VariablesDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1VariablesDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VariableResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VariableResponse[]>;
        }));
    }

    protected processGetApiV1VariablesDashboard(response: HttpResponseBase): Observable<VariableResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VariableResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1VariablesNamespace(namespaceId: string): Observable<VariableResponse[]> {
        let url_ = this.baseUrl + "/api/v1/variables/namespace/{namespaceId}";
        if (namespaceId === undefined || namespaceId === null)
            throw new Error("The parameter 'namespaceId' must be defined.");
        url_ = url_.replace("{namespaceId}", encodeURIComponent("" + namespaceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1VariablesNamespace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1VariablesNamespace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VariableResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VariableResponse[]>;
        }));
    }

    protected processGetApiV1VariablesNamespace(response: HttpResponseBase): Observable<VariableResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VariableResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1VariableRemove(variableId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/variable/remove/{variableId}";
        if (variableId === undefined || variableId === null)
            throw new Error("The parameter 'variableId' must be defined.");
        url_ = url_.replace("{variableId}", encodeURIComponent("" + variableId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1VariableRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1VariableRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1VariableRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiV1VariableUpdate(variableId: string, request: UpdateVariableRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/variable/update/{variableId}";
        if (variableId === undefined || variableId === null)
            throw new Error("The parameter 'variableId' must be defined.");
        url_ = url_.replace("{variableId}", encodeURIComponent("" + variableId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiV1VariableUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiV1VariableUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiV1VariableUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1UserLogin(email: string | null, password: string | null): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/v1/user/login?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (password === undefined)
            throw new Error("The parameter 'password' must be defined.");
        else if(password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1UserLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1UserLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processPostApiV1UserLogin(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1UserLoginCodeFlow(): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user/login-code-flow";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1UserLoginCodeFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1UserLoginCodeFlow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetApiV1UserLoginCodeFlow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 302) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1UserCallback(code: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user/callback?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1UserCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1UserCallback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetApiV1UserCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 302) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1TracesOperations(dataSourceName: string, serviceName: string): Observable<string[]> {
        let url_ = this.baseUrl + "/api/v1/traces/operations?";
        if (dataSourceName === undefined || dataSourceName === null)
            throw new Error("The parameter 'dataSourceName' must be defined and cannot be null.");
        else
            url_ += "dataSourceName=" + encodeURIComponent("" + dataSourceName) + "&";
        if (serviceName === undefined || serviceName === null)
            throw new Error("The parameter 'serviceName' must be defined and cannot be null.");
        else
            url_ += "serviceName=" + encodeURIComponent("" + serviceName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1TracesOperations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1TracesOperations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetApiV1TracesOperations(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1TracesServices(dataSourceName: string): Observable<string[]> {
        let url_ = this.baseUrl + "/api/v1/traces/services?";
        if (dataSourceName === undefined || dataSourceName === null)
            throw new Error("The parameter 'dataSourceName' must be defined and cannot be null.");
        else
            url_ += "dataSourceName=" + encodeURIComponent("" + dataSourceName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1TracesServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1TracesServices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetApiV1TracesServices(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1Traces(traceId: string, dataSourceName: string): Observable<TraceEntry> {
        let url_ = this.baseUrl + "/api/v1/traces/{traceId}?";
        if (traceId === undefined || traceId === null)
            throw new Error("The parameter 'traceId' must be defined.");
        url_ = url_.replace("{traceId}", encodeURIComponent("" + traceId));
        if (dataSourceName === undefined || dataSourceName === null)
            throw new Error("The parameter 'dataSourceName' must be defined and cannot be null.");
        else
            url_ += "dataSourceName=" + encodeURIComponent("" + dataSourceName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1Traces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1Traces(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TraceEntry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TraceEntry>;
        }));
    }

    protected processGetApiV1Traces(response: HttpResponseBase): Observable<TraceEntry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TraceEntry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1TracesSearch(request: SearchTracesRequest): Observable<TraceEntry[]> {
        let url_ = this.baseUrl + "/api/v1/traces/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1TracesSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1TracesSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TraceEntry[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TraceEntry[]>;
        }));
    }

    protected processPostApiV1TracesSearch(response: HttpResponseBase): Observable<TraceEntry[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TraceEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1SecretAdd(secret: SecretModel): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/secret/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(secret);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1SecretAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1SecretAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1SecretAdd(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1SecretRemove(key: string): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/secret/remove/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1SecretRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1SecretRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDeleteApiV1SecretRemove(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1Secret(key: string): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/secret/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1Secret(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1Secret(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetApiV1Secret(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1PluginAdd(request: AddPluginRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/plugin/add?";
        if (request === undefined || request === null)
            throw new Error("The parameter 'request' must be defined and cannot be null.");
        else
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1PluginAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1PluginAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1PluginAdd(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1Plugin(id: string): Observable<GetPluginResponse> {
        let url_ = this.baseUrl + "/api/v1/plugin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1Plugin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1Plugin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPluginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPluginResponse>;
        }));
    }

    protected processGetApiV1Plugin(response: HttpResponseBase): Observable<GetPluginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPluginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1PluginRemove(pluginId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/plugin/remove/{pluginId}";
        if (pluginId === undefined || pluginId === null)
            throw new Error("The parameter 'pluginId' must be defined.");
        url_ = url_.replace("{pluginId}", encodeURIComponent("" + pluginId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1PluginRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1PluginRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1PluginRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1PluginSearch(filters: SearchFilters, page?: number | undefined, pageSize?: number | undefined): Observable<PageOfSearchPluginsResponse> {
        let url_ = this.baseUrl + "/api/v1/plugin/search?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1PluginSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1PluginSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageOfSearchPluginsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageOfSearchPluginsResponse>;
        }));
    }

    protected processGetApiV1PluginSearch(response: HttpResponseBase): Observable<PageOfSearchPluginsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfSearchPluginsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1Plugin(pluginId: string, isActive?: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/plugin/{pluginId}?";
        if (pluginId === undefined || pluginId === null)
            throw new Error("The parameter 'pluginId' must be defined.");
        url_ = url_.replace("{pluginId}", encodeURIComponent("" + pluginId));
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1Plugin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1Plugin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiV1Plugin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiV1PluginUpdate(pluginId: string, request: UpdatePluginRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/plugin/update/{pluginId}";
        if (pluginId === undefined || pluginId === null)
            throw new Error("The parameter 'pluginId' must be defined.");
        url_ = url_.replace("{pluginId}", encodeURIComponent("" + pluginId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiV1PluginUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiV1PluginUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiV1PluginUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1PanelAdd(request: AddPanelRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/panel/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1PanelAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1PanelAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1PanelAdd(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1Panel(id: string): Observable<GetPanelResponse> {
        let url_ = this.baseUrl + "/api/v1/panel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1Panel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1Panel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPanelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPanelResponse>;
        }));
    }

    protected processGetApiV1Panel(response: HttpResponseBase): Observable<GetPanelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPanelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1PanelTypes(): Observable<GetPanelTypesResponse[]> {
        let url_ = this.baseUrl + "/api/v1/panel/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1PanelTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1PanelTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPanelTypesResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPanelTypesResponse[]>;
        }));
    }

    protected processGetApiV1PanelTypes(response: HttpResponseBase): Observable<GetPanelTypesResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPanelTypesResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1PanelRemove(panelId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/panel/remove/{panelId}";
        if (panelId === undefined || panelId === null)
            throw new Error("The parameter 'panelId' must be defined.");
        url_ = url_.replace("{panelId}", encodeURIComponent("" + panelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1PanelRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1PanelRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1PanelRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiV1PanelUpdate(panelId: string, request: UpdatePanelRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/panel/update/{panelId}";
        if (panelId === undefined || panelId === null)
            throw new Error("The parameter 'panelId' must be defined.");
        url_ = url_.replace("{panelId}", encodeURIComponent("" + panelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiV1PanelUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiV1PanelUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiV1PanelUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1NotificationDestinationAdd(request: AddNotificationDestinationRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/notification-destination/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1NotificationDestinationAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1NotificationDestinationAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPostApiV1NotificationDestinationAdd(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1NotificationDestination(name: string): Observable<GetNotificationDestinationResponse> {
        let url_ = this.baseUrl + "/api/v1/notification-destination/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1NotificationDestination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1NotificationDestination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationDestinationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationDestinationResponse>;
        }));
    }

    protected processGetApiV1NotificationDestination(response: HttpResponseBase): Observable<GetNotificationDestinationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationDestinationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1NotificationDestinationRemove(name: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/notification-destination/remove/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1NotificationDestinationRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1NotificationDestinationRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1NotificationDestinationRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1NotificationChannelAdd(request: AddNotificationChannelRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/notification-channel/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1NotificationChannelAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1NotificationChannelAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPostApiV1NotificationChannelAdd(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1NotificationChannel(id: number): Observable<NotificationChannelResponse> {
        let url_ = this.baseUrl + "/api/v1/notification-channel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1NotificationChannel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1NotificationChannel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationChannelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationChannelResponse>;
        }));
    }

    protected processGetApiV1NotificationChannel(response: HttpResponseBase): Observable<NotificationChannelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationChannelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1NotificationChannelRemove(notificationChannelId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/notification-channel/remove/{notificationChannelId}";
        if (notificationChannelId === undefined || notificationChannelId === null)
            throw new Error("The parameter 'notificationChannelId' must be defined.");
        url_ = url_.replace("{notificationChannelId}", encodeURIComponent("" + notificationChannelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1NotificationChannelRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1NotificationChannelRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1NotificationChannelRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiV1NotificationChannel(notificationChannelId: number, request: UpdateNotificationChannelRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/notification-channel/{notificationChannelId}";
        if (notificationChannelId === undefined || notificationChannelId === null)
            throw new Error("The parameter 'notificationChannelId' must be defined.");
        url_ = url_.replace("{notificationChannelId}", encodeURIComponent("" + notificationChannelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiV1NotificationChannel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiV1NotificationChannel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiV1NotificationChannel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1NotificationChannelGroupAdd(request: AddNotificationChannelGroupRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/notification-channel-group/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1NotificationChannelGroupAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1NotificationChannelGroupAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1NotificationChannelGroupAdd(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1NotificationChannelGroupGetAll(): Observable<NotificationChannelGroupResponse[]> {
        let url_ = this.baseUrl + "/api/v1/notification-channel-group/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1NotificationChannelGroupGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1NotificationChannelGroupGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationChannelGroupResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationChannelGroupResponse[]>;
        }));
    }

    protected processGetApiV1NotificationChannelGroupGetAll(response: HttpResponseBase): Observable<NotificationChannelGroupResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationChannelGroupResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1NotificationChannelGroup(id: string): Observable<NotificationChannelGroupResponse> {
        let url_ = this.baseUrl + "/api/v1/notification-channel-group/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1NotificationChannelGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1NotificationChannelGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationChannelGroupResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationChannelGroupResponse>;
        }));
    }

    protected processGetApiV1NotificationChannelGroup(response: HttpResponseBase): Observable<NotificationChannelGroupResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationChannelGroupResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1Namespace(request: AddNamespaceRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/namespace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1Namespace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1Namespace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1Namespace(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1Namespace(name: string): Observable<NamespaceByNameResponse> {
        let url_ = this.baseUrl + "/api/v1/namespace/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1Namespace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1Namespace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NamespaceByNameResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NamespaceByNameResponse>;
        }));
    }

    protected processGetApiV1Namespace(response: HttpResponseBase): Observable<NamespaceByNameResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamespaceByNameResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1MetricsQuery(dataSourceName: string | null, query: string | null, namespaceId: string, dashboardId?: string | null | undefined, from?: Date | null | undefined, to?: Date | null | undefined, step?: string | null | undefined): Observable<MetricPoint[]> {
        let url_ = this.baseUrl + "/api/v1/metrics/query?";
        if (dataSourceName === undefined)
            throw new Error("The parameter 'dataSourceName' must be defined.");
        else if(dataSourceName !== null)
            url_ += "DataSourceName=" + encodeURIComponent("" + dataSourceName) + "&";
        if (query === undefined)
            throw new Error("The parameter 'query' must be defined.");
        else if(query !== null)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (namespaceId === undefined || namespaceId === null)
            throw new Error("The parameter 'namespaceId' must be defined and cannot be null.");
        else
            url_ += "NamespaceId=" + encodeURIComponent("" + namespaceId) + "&";
        if (dashboardId !== undefined && dashboardId !== null)
            url_ += "DashboardId=" + encodeURIComponent("" + dashboardId) + "&";
        if (from !== undefined && from !== null)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (step !== undefined && step !== null)
            url_ += "Step=" + encodeURIComponent("" + step) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1MetricsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1MetricsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MetricPoint[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MetricPoint[]>;
        }));
    }

    protected processGetApiV1MetricsQuery(response: HttpResponseBase): Observable<MetricPoint[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MetricPoint.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1MetricsQueryRange(dataSourceName: string | null, query: string | null, namespaceId: string, dashboardId?: string | null | undefined, from?: Date | null | undefined, to?: Date | null | undefined, step?: string | null | undefined): Observable<TimeSeries[]> {
        let url_ = this.baseUrl + "/api/v1/metrics/query-range?";
        if (dataSourceName === undefined)
            throw new Error("The parameter 'dataSourceName' must be defined.");
        else if(dataSourceName !== null)
            url_ += "DataSourceName=" + encodeURIComponent("" + dataSourceName) + "&";
        if (query === undefined)
            throw new Error("The parameter 'query' must be defined.");
        else if(query !== null)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (namespaceId === undefined || namespaceId === null)
            throw new Error("The parameter 'namespaceId' must be defined and cannot be null.");
        else
            url_ += "NamespaceId=" + encodeURIComponent("" + namespaceId) + "&";
        if (dashboardId !== undefined && dashboardId !== null)
            url_ += "DashboardId=" + encodeURIComponent("" + dashboardId) + "&";
        if (from !== undefined && from !== null)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (step !== undefined && step !== null)
            url_ += "Step=" + encodeURIComponent("" + step) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1MetricsQueryRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1MetricsQueryRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimeSeries[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimeSeries[]>;
        }));
    }

    protected processGetApiV1MetricsQueryRange(response: HttpResponseBase): Observable<TimeSeries[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimeSeries.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1MetaDatabaseSchema(): Observable<SchemaResponse[]> {
        let url_ = this.baseUrl + "/api/v1/meta/database-schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1MetaDatabaseSchema(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1MetaDatabaseSchema(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaResponse[]>;
        }));
    }

    protected processGetApiV1MetaDatabaseSchema(response: HttpResponseBase): Observable<SchemaResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1MetaSqlQueries(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/v1/meta/sql-queries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1MetaSqlQueries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1MetaSqlQueries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetApiV1MetaSqlQueries(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1LogsSearch(request: SearchLogsRequest): Observable<PageOfLogEntry> {
        let url_ = this.baseUrl + "/api/v1/logs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1LogsSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1LogsSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageOfLogEntry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageOfLogEntry>;
        }));
    }

    protected processPostApiV1LogsSearch(response: HttpResponseBase): Observable<PageOfLogEntry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfLogEntry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1ExternalRole(request: AddExternalRoleMappingRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/external-role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1ExternalRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1ExternalRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiV1ExternalRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1DebugRollback(steps: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/debug/rollback/{steps}";
        if (steps === undefined || steps === null)
            throw new Error("The parameter 'steps' must be defined.");
        url_ = url_.replace("{steps}", encodeURIComponent("" + steps));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1DebugRollback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1DebugRollback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1DebugRollback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1DataSourceTypeAdd(request: AddDataSourceTypeRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/data-source-type/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1DataSourceTypeAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1DataSourceTypeAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPostApiV1DataSourceTypeAdd(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1DataSourceTypeGetAll(): Observable<GetDataSourceTypeResponse[]> {
        let url_ = this.baseUrl + "/api/v1/data-source-type/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1DataSourceTypeGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1DataSourceTypeGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDataSourceTypeResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDataSourceTypeResponse[]>;
        }));
    }

    protected processGetApiV1DataSourceTypeGetAll(response: HttpResponseBase): Observable<GetDataSourceTypeResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDataSourceTypeResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1DataSourceType(name: string): Observable<GetDataSourceTypeResponse> {
        let url_ = this.baseUrl + "/api/v1/data-source-type/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1DataSourceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1DataSourceType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDataSourceTypeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDataSourceTypeResponse>;
        }));
    }

    protected processGetApiV1DataSourceType(response: HttpResponseBase): Observable<GetDataSourceTypeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDataSourceTypeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1DatasourceRemove(name: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/datasource/remove/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1DatasourceRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1DatasourceRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1DatasourceRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1DataSourceAdd(request: AddDataSourceRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/data-source/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1DataSourceAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1DataSourceAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1DataSourceAdd(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1DataSource(id: string): Observable<GetDataSourceResponse> {
        let url_ = this.baseUrl + "/api/v1/data-source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1DataSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1DataSource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDataSourceResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDataSourceResponse>;
        }));
    }

    protected processGetApiV1DataSource(response: HttpResponseBase): Observable<GetDataSourceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDataSourceResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1DataSourceRemove(dataSourceId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/data-source/remove/{dataSourceId}";
        if (dataSourceId === undefined || dataSourceId === null)
            throw new Error("The parameter 'dataSourceId' must be defined.");
        url_ = url_.replace("{dataSourceId}", encodeURIComponent("" + dataSourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1DataSourceRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1DataSourceRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1DataSourceRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1DataSourceSearch(filters: SearchFilters, page?: number | undefined, pageSize?: number | undefined): Observable<PageOfSearchDataSourcesResponse> {
        let url_ = this.baseUrl + "/api/v1/data-source/search?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1DataSourceSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1DataSourceSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageOfSearchDataSourcesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageOfSearchDataSourcesResponse>;
        }));
    }

    protected processPostApiV1DataSourceSearch(response: HttpResponseBase): Observable<PageOfSearchDataSourcesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfSearchDataSourcesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiV1DataSourceUpdateConnectionString(dataSourceId: string, request: UpdateDataSourceRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/data-source/update-connection-string/{dataSourceId}";
        if (dataSourceId === undefined || dataSourceId === null)
            throw new Error("The parameter 'dataSourceId' must be defined.");
        url_ = url_.replace("{dataSourceId}", encodeURIComponent("" + dataSourceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiV1DataSourceUpdateConnectionString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiV1DataSourceUpdateConnectionString(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiV1DataSourceUpdateConnectionString(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1DashboardAdd(request: AddDashboardRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/dashboard/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1DashboardAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1DashboardAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1DashboardAdd(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1Dashboard(id: string): Observable<DashboardResponse> {
        let url_ = this.baseUrl + "/api/v1/dashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1Dashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1Dashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardResponse>;
        }));
    }

    protected processGetApiV1Dashboard(response: HttpResponseBase): Observable<DashboardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1DashboardFull(id: string): Observable<GetFullInfoDashboardResponse> {
        let url_ = this.baseUrl + "/api/v1/dashboard/{id}/full";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1DashboardFull(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1DashboardFull(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFullInfoDashboardResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFullInfoDashboardResponse>;
        }));
    }

    protected processGetApiV1DashboardFull(response: HttpResponseBase): Observable<GetFullInfoDashboardResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFullInfoDashboardResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1DashboardRemove(dashboardId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/dashboard/remove/{dashboardId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1DashboardRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1DashboardRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1DashboardRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1DashboardSearch(filters: SearchFilters, page?: number | undefined, pageSize?: number | undefined): Observable<PageOfSearchDashboardsResponse> {
        let url_ = this.baseUrl + "/api/v1/dashboard/search?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1DashboardSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1DashboardSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageOfSearchDashboardsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageOfSearchDashboardsResponse>;
        }));
    }

    protected processPostApiV1DashboardSearch(response: HttpResponseBase): Observable<PageOfSearchDashboardsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfSearchDashboardsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiV1DashboardUpdate(dashboardId: string, request: UpdateDashboardRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/dashboard/update/{dashboardId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiV1DashboardUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiV1DashboardUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiV1DashboardUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1AlertAdd(request: AddAlertRequest): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/alert/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1AlertAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1AlertAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1AlertAdd(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1Alert(id: string): Observable<GetAlertResponse> {
        let url_ = this.baseUrl + "/api/v1/alert/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1Alert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1Alert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAlertResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAlertResponse>;
        }));
    }

    protected processGetApiV1Alert(response: HttpResponseBase): Observable<GetAlertResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAlertResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiV1AlertTemplateVars(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/v1/alert/template-vars";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiV1AlertTemplateVars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiV1AlertTemplateVars(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetApiV1AlertTemplateVars(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1AlertMute(alertId: string, nextExecutionTime: string): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/alert/mute/{alertId}?";
        if (alertId === undefined || alertId === null)
            throw new Error("The parameter 'alertId' must be defined.");
        url_ = url_.replace("{alertId}", encodeURIComponent("" + alertId));
        if (nextExecutionTime === undefined || nextExecutionTime === null)
            throw new Error("The parameter 'nextExecutionTime' must be defined and cannot be null.");
        else
            url_ += "nextExecutionTime=" + encodeURIComponent("" + nextExecutionTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1AlertMute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1AlertMute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPostApiV1AlertMute(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiV1AlertRemove(alertId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/alert/remove/{alertId}";
        if (alertId === undefined || alertId === null)
            throw new Error("The parameter 'alertId' must be defined.");
        url_ = url_.replace("{alertId}", encodeURIComponent("" + alertId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiV1AlertRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiV1AlertRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiV1AlertRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiV1AlertSearch(filters: SearchFilters, page?: number | undefined, pageSize?: number | undefined): Observable<PageOfSearchAlertsResponse> {
        let url_ = this.baseUrl + "/api/v1/alert/search?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiV1AlertSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiV1AlertSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PageOfSearchAlertsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PageOfSearchAlertsResponse>;
        }));
    }

    protected processPostApiV1AlertSearch(response: HttpResponseBase): Observable<PageOfSearchAlertsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfSearchAlertsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiV1AlertUpdate(alertId: string, request: UpdateAlertRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/alert/update/{alertId}";
        if (alertId === undefined || alertId === null)
            throw new Error("The parameter 'alertId' must be defined.");
        url_ = url_.replace("{alertId}", encodeURIComponent("" + alertId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiV1AlertUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiV1AlertUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiV1AlertUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }

    clone(): ProblemDetails {
        const json = this.toJSON();
        let result = new ProblemDetails();
        result.init(json);
        return result;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class AddVariableRequest implements IAddVariableRequest {
    placeholder?: string;
    value?: string;
    namespaceId?: string;
    dashboardId?: string | undefined;

    constructor(data?: IAddVariableRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeholder = _data["placeholder"];
            this.value = _data["value"];
            this.namespaceId = _data["namespaceId"];
            this.dashboardId = _data["dashboardId"];
        }
    }

    static fromJS(data: any): AddVariableRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddVariableRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placeholder"] = this.placeholder;
        data["value"] = this.value;
        data["namespaceId"] = this.namespaceId;
        data["dashboardId"] = this.dashboardId;
        return data;
    }

    clone(): AddVariableRequest {
        const json = this.toJSON();
        let result = new AddVariableRequest();
        result.init(json);
        return result;
    }
}

export interface IAddVariableRequest {
    placeholder?: string;
    value?: string;
    namespaceId?: string;
    dashboardId?: string | undefined;
}

export class VariableResponse implements IVariableResponse {
    id?: string;
    placeholder?: string;
    value?: string;
    namespaceId?: string;
    dashboardId?: string | undefined;

    constructor(data?: IVariableResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.placeholder = _data["placeholder"];
            this.value = _data["value"];
            this.namespaceId = _data["namespaceId"];
            this.dashboardId = _data["dashboardId"];
        }
    }

    static fromJS(data: any): VariableResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VariableResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["placeholder"] = this.placeholder;
        data["value"] = this.value;
        data["namespaceId"] = this.namespaceId;
        data["dashboardId"] = this.dashboardId;
        return data;
    }

    clone(): VariableResponse {
        const json = this.toJSON();
        let result = new VariableResponse();
        result.init(json);
        return result;
    }
}

export interface IVariableResponse {
    id?: string;
    placeholder?: string;
    value?: string;
    namespaceId?: string;
    dashboardId?: string | undefined;
}

export class UpdateVariableRequest implements IUpdateVariableRequest {
    placeholder?: string;
    value?: string;

    constructor(data?: IUpdateVariableRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeholder = _data["placeholder"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateVariableRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVariableRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placeholder"] = this.placeholder;
        data["value"] = this.value;
        return data;
    }

    clone(): UpdateVariableRequest {
        const json = this.toJSON();
        let result = new UpdateVariableRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateVariableRequest {
    placeholder?: string;
    value?: string;
}

export class AccessTokenResponse implements IAccessTokenResponse {
    accessToken?: string;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data;
    }

    clone(): AccessTokenResponse {
        const json = this.toJSON();
        let result = new AccessTokenResponse();
        result.init(json);
        return result;
    }
}

export interface IAccessTokenResponse {
    accessToken?: string;
}

export class TraceEntry implements ITraceEntry {
    traceId?: string;
    spans?: SpanEntry[];
    processes?: { [key: string]: ProcessEntry; };

    constructor(data?: ITraceEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traceId = _data["traceId"];
            if (Array.isArray(_data["spans"])) {
                this.spans = [] as any;
                for (let item of _data["spans"])
                    this.spans!.push(SpanEntry.fromJS(item));
            }
            if (_data["processes"]) {
                this.processes = {} as any;
                for (let key in _data["processes"]) {
                    if (_data["processes"].hasOwnProperty(key))
                        (<any>this.processes)![key] = _data["processes"][key] ? ProcessEntry.fromJS(_data["processes"][key]) : new ProcessEntry();
                }
            }
        }
    }

    static fromJS(data: any): TraceEntry {
        data = typeof data === 'object' ? data : {};
        let result = new TraceEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traceId"] = this.traceId;
        if (Array.isArray(this.spans)) {
            data["spans"] = [];
            for (let item of this.spans)
                data["spans"].push(item.toJSON());
        }
        if (this.processes) {
            data["processes"] = {};
            for (let key in this.processes) {
                if (this.processes.hasOwnProperty(key))
                    (<any>data["processes"])[key] = this.processes[key] ? this.processes[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }

    clone(): TraceEntry {
        const json = this.toJSON();
        let result = new TraceEntry();
        result.init(json);
        return result;
    }
}

export interface ITraceEntry {
    traceId?: string;
    spans?: SpanEntry[];
    processes?: { [key: string]: ProcessEntry; };
}

export class SpanEntry implements ISpanEntry {
    traceId?: string;
    spanId?: string;
    operationName?: string;
    startTime?: Date;
    timestamp?: number;
    duration?: string;
    tags?: { [key: string]: any; };
    references?: SpanReference[];
    processId?: string;

    constructor(data?: ISpanEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traceId = _data["traceId"];
            this.spanId = _data["spanId"];
            this.operationName = _data["operationName"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.timestamp = _data["timestamp"];
            this.duration = _data["duration"];
            if (_data["tags"]) {
                this.tags = {} as any;
                for (let key in _data["tags"]) {
                    if (_data["tags"].hasOwnProperty(key))
                        (<any>this.tags)![key] = _data["tags"][key];
                }
            }
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(SpanReference.fromJS(item));
            }
            this.processId = _data["processId"];
        }
    }

    static fromJS(data: any): SpanEntry {
        data = typeof data === 'object' ? data : {};
        let result = new SpanEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traceId"] = this.traceId;
        data["spanId"] = this.spanId;
        data["operationName"] = this.operationName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["timestamp"] = this.timestamp;
        data["duration"] = this.duration;
        if (this.tags) {
            data["tags"] = {};
            for (let key in this.tags) {
                if (this.tags.hasOwnProperty(key))
                    (<any>data["tags"])[key] = (<any>this.tags)[key];
            }
        }
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item.toJSON());
        }
        data["processId"] = this.processId;
        return data;
    }

    clone(): SpanEntry {
        const json = this.toJSON();
        let result = new SpanEntry();
        result.init(json);
        return result;
    }
}

export interface ISpanEntry {
    traceId?: string;
    spanId?: string;
    operationName?: string;
    startTime?: Date;
    timestamp?: number;
    duration?: string;
    tags?: { [key: string]: any; };
    references?: SpanReference[];
    processId?: string;
}

export class SpanReference implements ISpanReference {
    traceId?: string;
    spanId?: string;
    referenceType?: SpanReferenceType;

    constructor(data?: ISpanReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traceId = _data["traceId"];
            this.spanId = _data["spanId"];
            this.referenceType = _data["referenceType"];
        }
    }

    static fromJS(data: any): SpanReference {
        data = typeof data === 'object' ? data : {};
        let result = new SpanReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traceId"] = this.traceId;
        data["spanId"] = this.spanId;
        data["referenceType"] = this.referenceType;
        return data;
    }

    clone(): SpanReference {
        const json = this.toJSON();
        let result = new SpanReference();
        result.init(json);
        return result;
    }
}

export interface ISpanReference {
    traceId?: string;
    spanId?: string;
    referenceType?: SpanReferenceType;
}

export enum SpanReferenceType {
    ChildOf = "childOf",
    FollowsFrom = "followsFrom",
    Other = "other",
}

export class ProcessEntry implements IProcessEntry {
    serviceName?: string;
    tags?: { [key: string]: any; };

    constructor(data?: IProcessEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceName = _data["serviceName"];
            if (_data["tags"]) {
                this.tags = {} as any;
                for (let key in _data["tags"]) {
                    if (_data["tags"].hasOwnProperty(key))
                        (<any>this.tags)![key] = _data["tags"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProcessEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        if (this.tags) {
            data["tags"] = {};
            for (let key in this.tags) {
                if (this.tags.hasOwnProperty(key))
                    (<any>data["tags"])[key] = (<any>this.tags)[key];
            }
        }
        return data;
    }

    clone(): ProcessEntry {
        const json = this.toJSON();
        let result = new ProcessEntry();
        result.init(json);
        return result;
    }
}

export interface IProcessEntry {
    serviceName?: string;
    tags?: { [key: string]: any; };
}

export class SearchTracesRequest implements ISearchTracesRequest {
    dataSourceName?: string;
    service?: string;
    start?: Date;
    end?: Date;
    operation?: string | undefined;
    limit?: number | undefined;
    minDuration?: string | undefined;
    maxDuration?: string | undefined;
    tags?: { [key: string]: any; } | undefined;

    constructor(data?: ISearchTracesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataSourceName = _data["dataSourceName"];
            this.service = _data["service"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.operation = _data["operation"];
            this.limit = _data["limit"];
            this.minDuration = _data["minDuration"];
            this.maxDuration = _data["maxDuration"];
            if (_data["tags"]) {
                this.tags = {} as any;
                for (let key in _data["tags"]) {
                    if (_data["tags"].hasOwnProperty(key))
                        (<any>this.tags)![key] = _data["tags"][key];
                }
            }
        }
    }

    static fromJS(data: any): SearchTracesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchTracesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataSourceName"] = this.dataSourceName;
        data["service"] = this.service;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["operation"] = this.operation;
        data["limit"] = this.limit;
        data["minDuration"] = this.minDuration;
        data["maxDuration"] = this.maxDuration;
        if (this.tags) {
            data["tags"] = {};
            for (let key in this.tags) {
                if (this.tags.hasOwnProperty(key))
                    (<any>data["tags"])[key] = (<any>this.tags)[key];
            }
        }
        return data;
    }

    clone(): SearchTracesRequest {
        const json = this.toJSON();
        let result = new SearchTracesRequest();
        result.init(json);
        return result;
    }
}

export interface ISearchTracesRequest {
    dataSourceName?: string;
    service?: string;
    start?: Date;
    end?: Date;
    operation?: string | undefined;
    limit?: number | undefined;
    minDuration?: string | undefined;
    maxDuration?: string | undefined;
    tags?: { [key: string]: any; } | undefined;
}

export class SecretModel implements ISecretModel {
    key?: string;
    value?: string;

    constructor(data?: ISecretModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SecretModel {
        data = typeof data === 'object' ? data : {};
        let result = new SecretModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }

    clone(): SecretModel {
        const json = this.toJSON();
        let result = new SecretModel();
        result.init(json);
        return result;
    }
}

export interface ISecretModel {
    key?: string;
    value?: string;
}

export class AddPluginRequest implements IAddPluginRequest {
    file?: string;
    name?: string;
    version?: string;
    author?: string;
    description?: string | undefined;
    settings?: string | undefined;

    constructor(data?: IAddPluginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
            this.name = _data["name"];
            this.version = _data["version"];
            this.author = _data["author"];
            this.description = _data["description"];
            this.settings = _data["settings"];
        }
    }

    static fromJS(data: any): AddPluginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddPluginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        data["name"] = this.name;
        data["version"] = this.version;
        data["author"] = this.author;
        data["description"] = this.description;
        data["settings"] = this.settings;
        return data;
    }

    clone(): AddPluginRequest {
        const json = this.toJSON();
        let result = new AddPluginRequest();
        result.init(json);
        return result;
    }
}

export interface IAddPluginRequest {
    file?: string;
    name?: string;
    version?: string;
    author?: string;
    description?: string | undefined;
    settings?: string | undefined;
}

export class GetPluginResponse implements IGetPluginResponse {
    pluginId?: string;
    name?: string;
    version?: string | undefined;
    description?: string | undefined;
    author?: string;
    settings?: string | undefined;

    constructor(data?: IGetPluginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pluginId = _data["pluginId"];
            this.name = _data["name"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.author = _data["author"];
            this.settings = _data["settings"];
        }
    }

    static fromJS(data: any): GetPluginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPluginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pluginId"] = this.pluginId;
        data["name"] = this.name;
        data["version"] = this.version;
        data["description"] = this.description;
        data["author"] = this.author;
        data["settings"] = this.settings;
        return data;
    }

    clone(): GetPluginResponse {
        const json = this.toJSON();
        let result = new GetPluginResponse();
        result.init(json);
        return result;
    }
}

export interface IGetPluginResponse {
    pluginId?: string;
    name?: string;
    version?: string | undefined;
    description?: string | undefined;
    author?: string;
    settings?: string | undefined;
}

export class PageOfSearchPluginsResponse implements IPageOfSearchPluginsResponse {
    items?: SearchPluginsResponse[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPageOfSearchPluginsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchPluginsResponse.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PageOfSearchPluginsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfSearchPluginsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PageOfSearchPluginsResponse {
        const json = this.toJSON();
        let result = new PageOfSearchPluginsResponse();
        result.init(json);
        return result;
    }
}

export interface IPageOfSearchPluginsResponse {
    items?: SearchPluginsResponse[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SearchPluginsResponse implements ISearchPluginsResponse {
    pluginId?: string;
    name?: string;
    version?: string | undefined;
    description?: string | undefined;
    author?: string;
    settings?: string | undefined;

    constructor(data?: ISearchPluginsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pluginId = _data["pluginId"];
            this.name = _data["name"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.author = _data["author"];
            this.settings = _data["settings"];
        }
    }

    static fromJS(data: any): SearchPluginsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchPluginsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pluginId"] = this.pluginId;
        data["name"] = this.name;
        data["version"] = this.version;
        data["description"] = this.description;
        data["author"] = this.author;
        data["settings"] = this.settings;
        return data;
    }

    clone(): SearchPluginsResponse {
        const json = this.toJSON();
        let result = new SearchPluginsResponse();
        result.init(json);
        return result;
    }
}

export interface ISearchPluginsResponse {
    pluginId?: string;
    name?: string;
    version?: string | undefined;
    description?: string | undefined;
    author?: string;
    settings?: string | undefined;
}

export class SearchFilters implements ISearchFilters {
    filters?: SearchFilter[];
    sort?: Sort | undefined;

    constructor(data?: ISearchFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(SearchFilter.fromJS(item));
            }
            this.sort = _data["sort"] ? Sort.fromJS(_data["sort"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchFilters {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
        return data;
    }

    clone(): SearchFilters {
        const json = this.toJSON();
        let result = new SearchFilters();
        result.init(json);
        return result;
    }
}

export interface ISearchFilters {
    filters?: SearchFilter[];
    sort?: Sort | undefined;
}

export class SearchFilter implements ISearchFilter {
    key?: string;
    value?: any;
    matchMode?: MatchMode;
    fieldType?: SearchFieldType;

    constructor(data?: ISearchFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
            this.matchMode = _data["matchMode"];
            this.fieldType = _data["fieldType"];
        }
    }

    static fromJS(data: any): SearchFilter {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["matchMode"] = this.matchMode;
        data["fieldType"] = this.fieldType;
        return data;
    }

    clone(): SearchFilter {
        const json = this.toJSON();
        let result = new SearchFilter();
        result.init(json);
        return result;
    }
}

export interface ISearchFilter {
    key?: string;
    value?: any;
    matchMode?: MatchMode;
    fieldType?: SearchFieldType;
}

export enum MatchMode {
    Equals = "equals",
    StartsWith = "startsWith",
    Contains = "contains",
}

export enum SearchFieldType {
    String = "string",
    Number = "number",
    Date = "date",
    Boolean = "boolean",
    Array = "array",
}

export class Sort implements ISort {
    fieldName?: string;
    sortOrder?: SortOrder;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): Sort {
        const json = this.toJSON();
        let result = new Sort();
        result.init(json);
        return result;
    }
}

export interface ISort {
    fieldName?: string;
    sortOrder?: SortOrder;
}

export enum SortOrder {
    Asc = "asc",
    Desc = "desc",
}

export class UpdatePluginRequest implements IUpdatePluginRequest {
    description?: string;
    settings?: string | undefined;

    constructor(data?: IUpdatePluginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.settings = _data["settings"];
        }
    }

    static fromJS(data: any): UpdatePluginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePluginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["settings"] = this.settings;
        return data;
    }

    clone(): UpdatePluginRequest {
        const json = this.toJSON();
        let result = new UpdatePluginRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdatePluginRequest {
    description?: string;
    settings?: string | undefined;
}

export class AddPanelRequest implements IAddPanelRequest {
    title?: string;
    type?: number;
    rawQuery?: string;
    dataSourceId?: string;
    layout?: string;
    dashboardId?: string;
    styleConfiguration?: string;

    constructor(data?: IAddPanelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.type = _data["type"];
            this.rawQuery = _data["rawQuery"];
            this.dataSourceId = _data["dataSourceId"];
            this.layout = _data["layout"];
            this.dashboardId = _data["dashboardId"];
            this.styleConfiguration = _data["styleConfiguration"];
        }
    }

    static fromJS(data: any): AddPanelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddPanelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["type"] = this.type;
        data["rawQuery"] = this.rawQuery;
        data["dataSourceId"] = this.dataSourceId;
        data["layout"] = this.layout;
        data["dashboardId"] = this.dashboardId;
        data["styleConfiguration"] = this.styleConfiguration;
        return data;
    }

    clone(): AddPanelRequest {
        const json = this.toJSON();
        let result = new AddPanelRequest();
        result.init(json);
        return result;
    }
}

export interface IAddPanelRequest {
    title?: string;
    type?: number;
    rawQuery?: string;
    dataSourceId?: string;
    layout?: string;
    dashboardId?: string;
    styleConfiguration?: string;
}

export class GetPanelResponse implements IGetPanelResponse {
    id?: string;
    title?: string;
    typeName?: string;
    query?: RawQueryResponse;
    layout?: string;
    dashboardId?: string;
    styleConfiguration?: string | undefined;

    constructor(data?: IGetPanelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.typeName = _data["typeName"];
            this.query = _data["query"] ? RawQueryResponse.fromJS(_data["query"]) : <any>undefined;
            this.layout = _data["layout"];
            this.dashboardId = _data["dashboardId"];
            this.styleConfiguration = _data["styleConfiguration"];
        }
    }

    static fromJS(data: any): GetPanelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPanelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["typeName"] = this.typeName;
        data["query"] = this.query ? this.query.toJSON() : <any>undefined;
        data["layout"] = this.layout;
        data["dashboardId"] = this.dashboardId;
        data["styleConfiguration"] = this.styleConfiguration;
        return data;
    }

    clone(): GetPanelResponse {
        const json = this.toJSON();
        let result = new GetPanelResponse();
        result.init(json);
        return result;
    }
}

export interface IGetPanelResponse {
    id?: string;
    title?: string;
    typeName?: string;
    query?: RawQueryResponse;
    layout?: string;
    dashboardId?: string;
    styleConfiguration?: string | undefined;
}

export class RawQueryResponse implements IRawQueryResponse {
    query?: string;
    dataSource?: DataSourceResponse;

    constructor(data?: IRawQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.query = _data["query"];
            this.dataSource = _data["dataSource"] ? DataSourceResponse.fromJS(_data["dataSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RawQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RawQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["query"] = this.query;
        data["dataSource"] = this.dataSource ? this.dataSource.toJSON() : <any>undefined;
        return data;
    }

    clone(): RawQueryResponse {
        const json = this.toJSON();
        let result = new RawQueryResponse();
        result.init(json);
        return result;
    }
}

export interface IRawQueryResponse {
    query?: string;
    dataSource?: DataSourceResponse;
}

export class DataSourceResponse implements IDataSourceResponse {
    id?: string;
    name?: string;
    type?: string;
    connectionString?: string;

    constructor(data?: IDataSourceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.connectionString = _data["connectionString"];
        }
    }

    static fromJS(data: any): DataSourceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataSourceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["connectionString"] = this.connectionString;
        return data;
    }

    clone(): DataSourceResponse {
        const json = this.toJSON();
        let result = new DataSourceResponse();
        result.init(json);
        return result;
    }
}

export interface IDataSourceResponse {
    id?: string;
    name?: string;
    type?: string;
    connectionString?: string;
}

export class GetPanelTypesResponse implements IGetPanelTypesResponse {
    id?: number;
    name?: string;

    constructor(data?: IGetPanelTypesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetPanelTypesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPanelTypesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): GetPanelTypesResponse {
        const json = this.toJSON();
        let result = new GetPanelTypesResponse();
        result.init(json);
        return result;
    }
}

export interface IGetPanelTypesResponse {
    id?: number;
    name?: string;
}

export class UpdatePanelRequest implements IUpdatePanelRequest {
    title?: string;
    type?: number;
    rawQuery?: string;
    dataSourceId?: string;
    layout?: string;
    styleConfiguration?: string;

    constructor(data?: IUpdatePanelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.type = _data["type"];
            this.rawQuery = _data["rawQuery"];
            this.dataSourceId = _data["dataSourceId"];
            this.layout = _data["layout"];
            this.styleConfiguration = _data["styleConfiguration"];
        }
    }

    static fromJS(data: any): UpdatePanelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePanelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["type"] = this.type;
        data["rawQuery"] = this.rawQuery;
        data["dataSourceId"] = this.dataSourceId;
        data["layout"] = this.layout;
        data["styleConfiguration"] = this.styleConfiguration;
        return data;
    }

    clone(): UpdatePanelRequest {
        const json = this.toJSON();
        let result = new UpdatePanelRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdatePanelRequest {
    title?: string;
    type?: number;
    rawQuery?: string;
    dataSourceId?: string;
    layout?: string;
    styleConfiguration?: string;
}

export class AddNotificationDestinationRequest implements IAddNotificationDestinationRequest {
    name?: string;

    constructor(data?: IAddNotificationDestinationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AddNotificationDestinationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddNotificationDestinationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }

    clone(): AddNotificationDestinationRequest {
        const json = this.toJSON();
        let result = new AddNotificationDestinationRequest();
        result.init(json);
        return result;
    }
}

export interface IAddNotificationDestinationRequest {
    name?: string;
}

export class GetNotificationDestinationResponse implements IGetNotificationDestinationResponse {
    id?: number;
    name?: string;

    constructor(data?: IGetNotificationDestinationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetNotificationDestinationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationDestinationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): GetNotificationDestinationResponse {
        const json = this.toJSON();
        let result = new GetNotificationDestinationResponse();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationDestinationResponse {
    id?: number;
    name?: string;
}

export class AddNotificationChannelRequest implements IAddNotificationChannelRequest {
    notificationChannelGroupName?: string;
    destinationName?: string;
    settings?: string;

    constructor(data?: IAddNotificationChannelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationChannelGroupName = _data["notificationChannelGroupName"];
            this.destinationName = _data["destinationName"];
            this.settings = _data["settings"];
        }
    }

    static fromJS(data: any): AddNotificationChannelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddNotificationChannelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationChannelGroupName"] = this.notificationChannelGroupName;
        data["destinationName"] = this.destinationName;
        data["settings"] = this.settings;
        return data;
    }

    clone(): AddNotificationChannelRequest {
        const json = this.toJSON();
        let result = new AddNotificationChannelRequest();
        result.init(json);
        return result;
    }
}

export interface IAddNotificationChannelRequest {
    notificationChannelGroupName?: string;
    destinationName?: string;
    settings?: string;
}

export class NotificationChannelResponse implements INotificationChannelResponse {
    id?: number;
    destinationName?: string;
    settings?: string;

    constructor(data?: INotificationChannelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.destinationName = _data["destinationName"];
            this.settings = _data["settings"];
        }
    }

    static fromJS(data: any): NotificationChannelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationChannelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["destinationName"] = this.destinationName;
        data["settings"] = this.settings;
        return data;
    }

    clone(): NotificationChannelResponse {
        const json = this.toJSON();
        let result = new NotificationChannelResponse();
        result.init(json);
        return result;
    }
}

export interface INotificationChannelResponse {
    id?: number;
    destinationName?: string;
    settings?: string;
}

export class UpdateNotificationChannelRequest implements IUpdateNotificationChannelRequest {
    destinationName?: string;
    settings?: string;

    constructor(data?: IUpdateNotificationChannelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.destinationName = _data["destinationName"];
            this.settings = _data["settings"];
        }
    }

    static fromJS(data: any): UpdateNotificationChannelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationChannelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["destinationName"] = this.destinationName;
        data["settings"] = this.settings;
        return data;
    }

    clone(): UpdateNotificationChannelRequest {
        const json = this.toJSON();
        let result = new UpdateNotificationChannelRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateNotificationChannelRequest {
    destinationName?: string;
    settings?: string;
}

export class AddNotificationChannelGroupRequest implements IAddNotificationChannelGroupRequest {
    name?: string;

    constructor(data?: IAddNotificationChannelGroupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AddNotificationChannelGroupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddNotificationChannelGroupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }

    clone(): AddNotificationChannelGroupRequest {
        const json = this.toJSON();
        let result = new AddNotificationChannelGroupRequest();
        result.init(json);
        return result;
    }
}

export interface IAddNotificationChannelGroupRequest {
    name?: string;
}

export class NotificationChannelGroupResponse implements INotificationChannelGroupResponse {
    id?: string;
    name?: string;
    notificationChannels?: NotificationChannelResponse[];

    constructor(data?: INotificationChannelGroupResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["notificationChannels"])) {
                this.notificationChannels = [] as any;
                for (let item of _data["notificationChannels"])
                    this.notificationChannels!.push(NotificationChannelResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationChannelGroupResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationChannelGroupResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.notificationChannels)) {
            data["notificationChannels"] = [];
            for (let item of this.notificationChannels)
                data["notificationChannels"].push(item.toJSON());
        }
        return data;
    }

    clone(): NotificationChannelGroupResponse {
        const json = this.toJSON();
        let result = new NotificationChannelGroupResponse();
        result.init(json);
        return result;
    }
}

export interface INotificationChannelGroupResponse {
    id?: string;
    name?: string;
    notificationChannels?: NotificationChannelResponse[];
}

export class AddNamespaceRequest implements IAddNamespaceRequest {
    name?: string;

    constructor(data?: IAddNamespaceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AddNamespaceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddNamespaceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }

    clone(): AddNamespaceRequest {
        const json = this.toJSON();
        let result = new AddNamespaceRequest();
        result.init(json);
        return result;
    }
}

export interface IAddNamespaceRequest {
    name?: string;
}

export class NamespaceByNameResponse implements INamespaceByNameResponse {
    name?: string;
    dashboards?: DashboardResponse[];

    constructor(data?: INamespaceByNameResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["dashboards"])) {
                this.dashboards = [] as any;
                for (let item of _data["dashboards"])
                    this.dashboards!.push(DashboardResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NamespaceByNameResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NamespaceByNameResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.dashboards)) {
            data["dashboards"] = [];
            for (let item of this.dashboards)
                data["dashboards"].push(item.toJSON());
        }
        return data;
    }

    clone(): NamespaceByNameResponse {
        const json = this.toJSON();
        let result = new NamespaceByNameResponse();
        result.init(json);
        return result;
    }
}

export interface INamespaceByNameResponse {
    name?: string;
    dashboards?: DashboardResponse[];
}

export class DashboardResponse implements IDashboardResponse {
    id?: string;
    namespaceId?: string;
    name?: string;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    tags?: string[];

    constructor(data?: IDashboardResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.namespaceId = _data["namespaceId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): DashboardResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["namespaceId"] = this.namespaceId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }

    clone(): DashboardResponse {
        const json = this.toJSON();
        let result = new DashboardResponse();
        result.init(json);
        return result;
    }
}

export interface IDashboardResponse {
    id?: string;
    namespaceId?: string;
    name?: string;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    tags?: string[];
}

export class MetricPoint implements IMetricPoint {
    metricName?: string;
    value?: number;
    timestamp?: Date;
    labels?: { [key: string]: string; };

    constructor(data?: IMetricPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metricName = _data["metricName"];
            this.value = _data["value"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (_data["labels"]) {
                this.labels = {} as any;
                for (let key in _data["labels"]) {
                    if (_data["labels"].hasOwnProperty(key))
                        (<any>this.labels)![key] = _data["labels"][key];
                }
            }
        }
    }

    static fromJS(data: any): MetricPoint {
        data = typeof data === 'object' ? data : {};
        let result = new MetricPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metricName"] = this.metricName;
        data["value"] = this.value;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (this.labels) {
            data["labels"] = {};
            for (let key in this.labels) {
                if (this.labels.hasOwnProperty(key))
                    (<any>data["labels"])[key] = (<any>this.labels)[key];
            }
        }
        return data;
    }

    clone(): MetricPoint {
        const json = this.toJSON();
        let result = new MetricPoint();
        result.init(json);
        return result;
    }
}

export interface IMetricPoint {
    metricName?: string;
    value?: number;
    timestamp?: Date;
    labels?: { [key: string]: string; };
}

export class TimeSeries implements ITimeSeries {
    metricName?: string;
    labels?: { [key: string]: string; };
    points?: MetricPoint[];

    constructor(data?: ITimeSeries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metricName = _data["metricName"];
            if (_data["labels"]) {
                this.labels = {} as any;
                for (let key in _data["labels"]) {
                    if (_data["labels"].hasOwnProperty(key))
                        (<any>this.labels)![key] = _data["labels"][key];
                }
            }
            if (Array.isArray(_data["points"])) {
                this.points = [] as any;
                for (let item of _data["points"])
                    this.points!.push(MetricPoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeSeries {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSeries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metricName"] = this.metricName;
        if (this.labels) {
            data["labels"] = {};
            for (let key in this.labels) {
                if (this.labels.hasOwnProperty(key))
                    (<any>data["labels"])[key] = (<any>this.labels)[key];
            }
        }
        if (Array.isArray(this.points)) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        return data;
    }

    clone(): TimeSeries {
        const json = this.toJSON();
        let result = new TimeSeries();
        result.init(json);
        return result;
    }
}

export interface ITimeSeries {
    metricName?: string;
    labels?: { [key: string]: string; };
    points?: MetricPoint[];
}

export class SchemaResponse implements ISchemaResponse {
    migration?: string;
    upSql?: any;
    downSql?: any;

    constructor(data?: ISchemaResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.migration = _data["migration"];
            this.upSql = _data["upSql"];
            this.downSql = _data["downSql"];
        }
    }

    static fromJS(data: any): SchemaResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["migration"] = this.migration;
        data["upSql"] = this.upSql;
        data["downSql"] = this.downSql;
        return data;
    }

    clone(): SchemaResponse {
        const json = this.toJSON();
        let result = new SchemaResponse();
        result.init(json);
        return result;
    }
}

export interface ISchemaResponse {
    migration?: string;
    upSql?: any;
    downSql?: any;
}

export class PageOfLogEntry implements IPageOfLogEntry {
    items?: LogEntry[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPageOfLogEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LogEntry.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PageOfLogEntry {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfLogEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PageOfLogEntry {
        const json = this.toJSON();
        let result = new PageOfLogEntry();
        result.init(json);
        return result;
    }
}

export interface IPageOfLogEntry {
    items?: LogEntry[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class LogEntry implements ILogEntry {
    timestamp?: Date;
    message?: string;
    severity?: string;
    serviceName?: string;
    traceId?: string;
    additionalFields?: { [key: string]: any; };

    constructor(data?: ILogEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.message = _data["message"];
            this.severity = _data["severity"];
            this.serviceName = _data["serviceName"];
            this.traceId = _data["traceId"];
            if (_data["additionalFields"]) {
                this.additionalFields = {} as any;
                for (let key in _data["additionalFields"]) {
                    if (_data["additionalFields"].hasOwnProperty(key))
                        (<any>this.additionalFields)![key] = _data["additionalFields"][key];
                }
            }
        }
    }

    static fromJS(data: any): LogEntry {
        data = typeof data === 'object' ? data : {};
        let result = new LogEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["message"] = this.message;
        data["severity"] = this.severity;
        data["serviceName"] = this.serviceName;
        data["traceId"] = this.traceId;
        if (this.additionalFields) {
            data["additionalFields"] = {};
            for (let key in this.additionalFields) {
                if (this.additionalFields.hasOwnProperty(key))
                    (<any>data["additionalFields"])[key] = (<any>this.additionalFields)[key];
            }
        }
        return data;
    }

    clone(): LogEntry {
        const json = this.toJSON();
        let result = new LogEntry();
        result.init(json);
        return result;
    }
}

export interface ILogEntry {
    timestamp?: Date;
    message?: string;
    severity?: string;
    serviceName?: string;
    traceId?: string;
    additionalFields?: { [key: string]: any; };
}

export class SearchLogsRequest implements ISearchLogsRequest {
    dataSourceName?: string;
    traceId?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    severity?: string | undefined;
    serviceName?: string | undefined;
    customFilters?: { [key: string]: string; } | undefined;
    pageSize?: number;
    page?: number;
    sortField?: string | undefined;
    sortAscending?: boolean;

    constructor(data?: ISearchLogsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataSourceName = _data["dataSourceName"];
            this.traceId = _data["traceId"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            this.severity = _data["severity"];
            this.serviceName = _data["serviceName"];
            if (_data["customFilters"]) {
                this.customFilters = {} as any;
                for (let key in _data["customFilters"]) {
                    if (_data["customFilters"].hasOwnProperty(key))
                        (<any>this.customFilters)![key] = _data["customFilters"][key];
                }
            }
            this.pageSize = _data["pageSize"];
            this.page = _data["page"];
            this.sortField = _data["sortField"];
            this.sortAscending = _data["sortAscending"];
        }
    }

    static fromJS(data: any): SearchLogsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchLogsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataSourceName"] = this.dataSourceName;
        data["traceId"] = this.traceId;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["severity"] = this.severity;
        data["serviceName"] = this.serviceName;
        if (this.customFilters) {
            data["customFilters"] = {};
            for (let key in this.customFilters) {
                if (this.customFilters.hasOwnProperty(key))
                    (<any>data["customFilters"])[key] = (<any>this.customFilters)[key];
            }
        }
        data["pageSize"] = this.pageSize;
        data["page"] = this.page;
        data["sortField"] = this.sortField;
        data["sortAscending"] = this.sortAscending;
        return data;
    }

    clone(): SearchLogsRequest {
        const json = this.toJSON();
        let result = new SearchLogsRequest();
        result.init(json);
        return result;
    }
}

export interface ISearchLogsRequest {
    dataSourceName?: string;
    traceId?: string | undefined;
    from?: Date | undefined;
    to?: Date | undefined;
    severity?: string | undefined;
    serviceName?: string | undefined;
    customFilters?: { [key: string]: string; } | undefined;
    pageSize?: number;
    page?: number;
    sortField?: string | undefined;
    sortAscending?: boolean;
}

export class AddExternalRoleMappingRequest implements IAddExternalRoleMappingRequest {
    externalRole?: string;
    namespaceId?: string;
    roleId?: number;

    constructor(data?: IAddExternalRoleMappingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.externalRole = _data["externalRole"];
            this.namespaceId = _data["namespaceId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): AddExternalRoleMappingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddExternalRoleMappingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["externalRole"] = this.externalRole;
        data["namespaceId"] = this.namespaceId;
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): AddExternalRoleMappingRequest {
        const json = this.toJSON();
        let result = new AddExternalRoleMappingRequest();
        result.init(json);
        return result;
    }
}

export interface IAddExternalRoleMappingRequest {
    externalRole?: string;
    namespaceId?: string;
    roleId?: number;
}

export class AddDataSourceTypeRequest implements IAddDataSourceTypeRequest {
    name?: string;

    constructor(data?: IAddDataSourceTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AddDataSourceTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddDataSourceTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }

    clone(): AddDataSourceTypeRequest {
        const json = this.toJSON();
        let result = new AddDataSourceTypeRequest();
        result.init(json);
        return result;
    }
}

export interface IAddDataSourceTypeRequest {
    name?: string;
}

export class GetDataSourceTypeResponse implements IGetDataSourceTypeResponse {
    id?: number;
    name?: string;

    constructor(data?: IGetDataSourceTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetDataSourceTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataSourceTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): GetDataSourceTypeResponse {
        const json = this.toJSON();
        let result = new GetDataSourceTypeResponse();
        result.init(json);
        return result;
    }
}

export interface IGetDataSourceTypeResponse {
    id?: number;
    name?: string;
}

export class AddDataSourceRequest implements IAddDataSourceRequest {
    uniqueName?: string;
    dataSourceType?: string;
    connectionString?: string;
    purpose?: DataSourceKind;

    constructor(data?: IAddDataSourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueName = _data["uniqueName"];
            this.dataSourceType = _data["dataSourceType"];
            this.connectionString = _data["connectionString"];
            this.purpose = _data["purpose"];
        }
    }

    static fromJS(data: any): AddDataSourceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddDataSourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueName"] = this.uniqueName;
        data["dataSourceType"] = this.dataSourceType;
        data["connectionString"] = this.connectionString;
        data["purpose"] = this.purpose;
        return data;
    }

    clone(): AddDataSourceRequest {
        const json = this.toJSON();
        let result = new AddDataSourceRequest();
        result.init(json);
        return result;
    }
}

export interface IAddDataSourceRequest {
    uniqueName?: string;
    dataSourceType?: string;
    connectionString?: string;
    purpose?: DataSourceKind;
}

export enum DataSourceKind {
    Metrics = "metrics",
    Logs = "logs",
    Traces = "traces",
}

export class GetDataSourceResponse implements IGetDataSourceResponse {
    id?: string;
    name?: string;
    type?: string;
    connectionString?: string;

    constructor(data?: IGetDataSourceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.connectionString = _data["connectionString"];
        }
    }

    static fromJS(data: any): GetDataSourceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataSourceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["connectionString"] = this.connectionString;
        return data;
    }

    clone(): GetDataSourceResponse {
        const json = this.toJSON();
        let result = new GetDataSourceResponse();
        result.init(json);
        return result;
    }
}

export interface IGetDataSourceResponse {
    id?: string;
    name?: string;
    type?: string;
    connectionString?: string;
}

export class PageOfSearchDataSourcesResponse implements IPageOfSearchDataSourcesResponse {
    items?: SearchDataSourcesResponse[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPageOfSearchDataSourcesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchDataSourcesResponse.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PageOfSearchDataSourcesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfSearchDataSourcesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PageOfSearchDataSourcesResponse {
        const json = this.toJSON();
        let result = new PageOfSearchDataSourcesResponse();
        result.init(json);
        return result;
    }
}

export interface IPageOfSearchDataSourcesResponse {
    items?: SearchDataSourcesResponse[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SearchDataSourcesResponse implements ISearchDataSourcesResponse {
    id?: string;
    name?: string;
    type?: string;
    purpose?: string;
    connectionString?: string;

    constructor(data?: ISearchDataSourcesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.purpose = _data["purpose"];
            this.connectionString = _data["connectionString"];
        }
    }

    static fromJS(data: any): SearchDataSourcesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDataSourcesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["purpose"] = this.purpose;
        data["connectionString"] = this.connectionString;
        return data;
    }

    clone(): SearchDataSourcesResponse {
        const json = this.toJSON();
        let result = new SearchDataSourcesResponse();
        result.init(json);
        return result;
    }
}

export interface ISearchDataSourcesResponse {
    id?: string;
    name?: string;
    type?: string;
    purpose?: string;
    connectionString?: string;
}

export class UpdateDataSourceRequest implements IUpdateDataSourceRequest {
    connectionString?: string;

    constructor(data?: IUpdateDataSourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionString = _data["connectionString"];
        }
    }

    static fromJS(data: any): UpdateDataSourceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDataSourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        return data;
    }

    clone(): UpdateDataSourceRequest {
        const json = this.toJSON();
        let result = new UpdateDataSourceRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateDataSourceRequest {
    connectionString?: string;
}

export class AddDashboardRequest implements IAddDashboardRequest {
    name?: string;
    description?: string | undefined;
    namespaceId?: string;
    tags?: string[];

    constructor(data?: IAddDashboardRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.namespaceId = _data["namespaceId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): AddDashboardRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddDashboardRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["namespaceId"] = this.namespaceId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }

    clone(): AddDashboardRequest {
        const json = this.toJSON();
        let result = new AddDashboardRequest();
        result.init(json);
        return result;
    }
}

export interface IAddDashboardRequest {
    name?: string;
    description?: string | undefined;
    namespaceId?: string;
    tags?: string[];
}

export class GetFullInfoDashboardResponse implements IGetFullInfoDashboardResponse {
    id?: string;
    namespaceId?: string;
    name?: string;
    description?: string | undefined;
    panels?: SearchDashboardsPanelDetailsResponse[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    tags?: string[];

    constructor(data?: IGetFullInfoDashboardResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.namespaceId = _data["namespaceId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["panels"])) {
                this.panels = [] as any;
                for (let item of _data["panels"])
                    this.panels!.push(SearchDashboardsPanelDetailsResponse.fromJS(item));
            }
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): GetFullInfoDashboardResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetFullInfoDashboardResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["namespaceId"] = this.namespaceId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.panels)) {
            data["panels"] = [];
            for (let item of this.panels)
                data["panels"].push(item.toJSON());
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }

    clone(): GetFullInfoDashboardResponse {
        const json = this.toJSON();
        let result = new GetFullInfoDashboardResponse();
        result.init(json);
        return result;
    }
}

export interface IGetFullInfoDashboardResponse {
    id?: string;
    namespaceId?: string;
    name?: string;
    description?: string | undefined;
    panels?: SearchDashboardsPanelDetailsResponse[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    tags?: string[];
}

export class SearchDashboardsPanelDetailsResponse implements ISearchDashboardsPanelDetailsResponse {
    id?: string;
    title?: string | undefined;
    panelType?: string;
    query?: string;
    layout?: string;

    constructor(data?: ISearchDashboardsPanelDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.panelType = _data["panelType"];
            this.query = _data["query"];
            this.layout = _data["layout"];
        }
    }

    static fromJS(data: any): SearchDashboardsPanelDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDashboardsPanelDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["panelType"] = this.panelType;
        data["query"] = this.query;
        data["layout"] = this.layout;
        return data;
    }

    clone(): SearchDashboardsPanelDetailsResponse {
        const json = this.toJSON();
        let result = new SearchDashboardsPanelDetailsResponse();
        result.init(json);
        return result;
    }
}

export interface ISearchDashboardsPanelDetailsResponse {
    id?: string;
    title?: string | undefined;
    panelType?: string;
    query?: string;
    layout?: string;
}

export class PageOfSearchDashboardsResponse implements IPageOfSearchDashboardsResponse {
    items?: SearchDashboardsResponse[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPageOfSearchDashboardsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchDashboardsResponse.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PageOfSearchDashboardsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfSearchDashboardsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PageOfSearchDashboardsResponse {
        const json = this.toJSON();
        let result = new PageOfSearchDashboardsResponse();
        result.init(json);
        return result;
    }
}

export interface IPageOfSearchDashboardsResponse {
    items?: SearchDashboardsResponse[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SearchDashboardsResponse implements ISearchDashboardsResponse {
    id?: string;
    namespaceId?: string;
    name?: string;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    tags?: string[];

    constructor(data?: ISearchDashboardsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.namespaceId = _data["namespaceId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchDashboardsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDashboardsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["namespaceId"] = this.namespaceId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }

    clone(): SearchDashboardsResponse {
        const json = this.toJSON();
        let result = new SearchDashboardsResponse();
        result.init(json);
        return result;
    }
}

export interface ISearchDashboardsResponse {
    id?: string;
    namespaceId?: string;
    name?: string;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    tags?: string[];
}

export class UpdateDashboardRequest implements IUpdateDashboardRequest {
    name?: string;
    description?: string | undefined;

    constructor(data?: IUpdateDashboardRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateDashboardRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDashboardRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateDashboardRequest {
        const json = this.toJSON();
        let result = new UpdateDashboardRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateDashboardRequest {
    name?: string;
    description?: string | undefined;
}

export class AddAlertRequest implements IAddAlertRequest {
    description?: string | undefined;
    template?: string;
    rawQuery?: string;
    dataSourceId?: string;
    notificationChannelGroupName?: string;
    waitTimeBeforeAlerting?: string;
    repeatInterval?: string;
    tags?: string[];

    constructor(data?: IAddAlertRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.template = _data["template"];
            this.rawQuery = _data["rawQuery"];
            this.dataSourceId = _data["dataSourceId"];
            this.notificationChannelGroupName = _data["notificationChannelGroupName"];
            this.waitTimeBeforeAlerting = _data["waitTimeBeforeAlerting"];
            this.repeatInterval = _data["repeatInterval"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): AddAlertRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddAlertRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["template"] = this.template;
        data["rawQuery"] = this.rawQuery;
        data["dataSourceId"] = this.dataSourceId;
        data["notificationChannelGroupName"] = this.notificationChannelGroupName;
        data["waitTimeBeforeAlerting"] = this.waitTimeBeforeAlerting;
        data["repeatInterval"] = this.repeatInterval;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }

    clone(): AddAlertRequest {
        const json = this.toJSON();
        let result = new AddAlertRequest();
        result.init(json);
        return result;
    }
}

export interface IAddAlertRequest {
    description?: string | undefined;
    template?: string;
    rawQuery?: string;
    dataSourceId?: string;
    notificationChannelGroupName?: string;
    waitTimeBeforeAlerting?: string;
    repeatInterval?: string;
    tags?: string[];
}

export class GetAlertResponse implements IGetAlertResponse {
    id?: string;
    description?: string | undefined;
    template?: string;
    rawQuery?: string;
    status?: string;
    dataSource?: DataSourceResponse;
    notificationChannelGroup?: NotificationChannelGroupResponse;
    previousExecutionTime?: Date;
    nextExecutionTime?: Date;
    waitTimeBeforeAlerting?: string;
    repeatInterval?: string;
    tags?: string[];

    constructor(data?: IGetAlertResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.template = _data["template"];
            this.rawQuery = _data["rawQuery"];
            this.status = _data["status"];
            this.dataSource = _data["dataSource"] ? DataSourceResponse.fromJS(_data["dataSource"]) : <any>undefined;
            this.notificationChannelGroup = _data["notificationChannelGroup"] ? NotificationChannelGroupResponse.fromJS(_data["notificationChannelGroup"]) : <any>undefined;
            this.previousExecutionTime = _data["previousExecutionTime"] ? new Date(_data["previousExecutionTime"].toString()) : <any>undefined;
            this.nextExecutionTime = _data["nextExecutionTime"] ? new Date(_data["nextExecutionTime"].toString()) : <any>undefined;
            this.waitTimeBeforeAlerting = _data["waitTimeBeforeAlerting"];
            this.repeatInterval = _data["repeatInterval"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): GetAlertResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAlertResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["template"] = this.template;
        data["rawQuery"] = this.rawQuery;
        data["status"] = this.status;
        data["dataSource"] = this.dataSource ? this.dataSource.toJSON() : <any>undefined;
        data["notificationChannelGroup"] = this.notificationChannelGroup ? this.notificationChannelGroup.toJSON() : <any>undefined;
        data["previousExecutionTime"] = this.previousExecutionTime ? this.previousExecutionTime.toISOString() : <any>undefined;
        data["nextExecutionTime"] = this.nextExecutionTime ? this.nextExecutionTime.toISOString() : <any>undefined;
        data["waitTimeBeforeAlerting"] = this.waitTimeBeforeAlerting;
        data["repeatInterval"] = this.repeatInterval;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }

    clone(): GetAlertResponse {
        const json = this.toJSON();
        let result = new GetAlertResponse();
        result.init(json);
        return result;
    }
}

export interface IGetAlertResponse {
    id?: string;
    description?: string | undefined;
    template?: string;
    rawQuery?: string;
    status?: string;
    dataSource?: DataSourceResponse;
    notificationChannelGroup?: NotificationChannelGroupResponse;
    previousExecutionTime?: Date;
    nextExecutionTime?: Date;
    waitTimeBeforeAlerting?: string;
    repeatInterval?: string;
    tags?: string[];
}

export class PageOfSearchAlertsResponse implements IPageOfSearchAlertsResponse {
    items?: SearchAlertsResponse[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPageOfSearchAlertsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchAlertsResponse.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PageOfSearchAlertsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfSearchAlertsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PageOfSearchAlertsResponse {
        const json = this.toJSON();
        let result = new PageOfSearchAlertsResponse();
        result.init(json);
        return result;
    }
}

export interface IPageOfSearchAlertsResponse {
    items?: SearchAlertsResponse[];
    totalCount?: number;
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SearchAlertsResponse implements ISearchAlertsResponse {
    id?: string;
    description?: string | undefined;
    template?: string;
    rawQuery?: string;
    status?: string;
    dataSource?: DataSourceResponse;
    notificationChannelGroup?: NotificationChannelGroupResponse;
    previousExecutionTime?: Date;
    nextExecutionTime?: Date;
    waitTimeBeforeAlerting?: string;
    repeatInterval?: string;
    tags?: string[];

    constructor(data?: ISearchAlertsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.template = _data["template"];
            this.rawQuery = _data["rawQuery"];
            this.status = _data["status"];
            this.dataSource = _data["dataSource"] ? DataSourceResponse.fromJS(_data["dataSource"]) : <any>undefined;
            this.notificationChannelGroup = _data["notificationChannelGroup"] ? NotificationChannelGroupResponse.fromJS(_data["notificationChannelGroup"]) : <any>undefined;
            this.previousExecutionTime = _data["previousExecutionTime"] ? new Date(_data["previousExecutionTime"].toString()) : <any>undefined;
            this.nextExecutionTime = _data["nextExecutionTime"] ? new Date(_data["nextExecutionTime"].toString()) : <any>undefined;
            this.waitTimeBeforeAlerting = _data["waitTimeBeforeAlerting"];
            this.repeatInterval = _data["repeatInterval"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchAlertsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchAlertsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["template"] = this.template;
        data["rawQuery"] = this.rawQuery;
        data["status"] = this.status;
        data["dataSource"] = this.dataSource ? this.dataSource.toJSON() : <any>undefined;
        data["notificationChannelGroup"] = this.notificationChannelGroup ? this.notificationChannelGroup.toJSON() : <any>undefined;
        data["previousExecutionTime"] = this.previousExecutionTime ? this.previousExecutionTime.toISOString() : <any>undefined;
        data["nextExecutionTime"] = this.nextExecutionTime ? this.nextExecutionTime.toISOString() : <any>undefined;
        data["waitTimeBeforeAlerting"] = this.waitTimeBeforeAlerting;
        data["repeatInterval"] = this.repeatInterval;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }

    clone(): SearchAlertsResponse {
        const json = this.toJSON();
        let result = new SearchAlertsResponse();
        result.init(json);
        return result;
    }
}

export interface ISearchAlertsResponse {
    id?: string;
    description?: string | undefined;
    template?: string;
    rawQuery?: string;
    status?: string;
    dataSource?: DataSourceResponse;
    notificationChannelGroup?: NotificationChannelGroupResponse;
    previousExecutionTime?: Date;
    nextExecutionTime?: Date;
    waitTimeBeforeAlerting?: string;
    repeatInterval?: string;
    tags?: string[];
}

export class UpdateAlertRequest implements IUpdateAlertRequest {
    description?: string | undefined;
    template?: string;
    rawQuery?: string;
    dataSourceId?: string;

    constructor(data?: IUpdateAlertRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.template = _data["template"];
            this.rawQuery = _data["rawQuery"];
            this.dataSourceId = _data["dataSourceId"];
        }
    }

    static fromJS(data: any): UpdateAlertRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAlertRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["template"] = this.template;
        data["rawQuery"] = this.rawQuery;
        data["dataSourceId"] = this.dataSourceId;
        return data;
    }

    clone(): UpdateAlertRequest {
        const json = this.toJSON();
        let result = new UpdateAlertRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateAlertRequest {
    description?: string | undefined;
    template?: string;
    rawQuery?: string;
    dataSourceId?: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}